<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" lang="en">
    <title>Crop Circles</title>
    <link rel="stylesheet" href="libs/ttf-iosevka-aile-3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        :root {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --users-guide-background-color: #111;

            --status-background-color: #444;

            --precision-helper-background-color: #000;

            --main-background-color: #131313;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --input-danger-color: orangered;

            --dropper-background-color: #555;
            --dropper-color: #aaa;

            --current-selection-stroke: #fff;
            --old-selections-stroke: rgba(255,255,255,0.5);
            --old-selections-fill: rgba(255,255,255,0.2);
            --highlighted-selection-stroke: rgba(255,255,255,0.8);
            --highlighted-selection-fill: rgba(255,255,255,0.4);

            --precision-helper-dividers-stroke: #555;
        }
        html {
            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        h1 svg {
            height: 0.75em;
            margin: 0 -0.05em 0 0.05em;
        }
        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem
        }
        button, label, input[type="text"] {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem
        }
        button:hover, label:hover, input[type="text"]:hover {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button {
            cursor: pointer;
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        input[type="checkbox"] {
            height: 1.25em;
            margin-right: 0.3em;
            vertical-align: text-bottom;  /* hack to make it look vertically centered in chrome but doesn't in firefox... hmm */
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"] {
            text-transform: none;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            float: right;
            font-weight: normal;
            text-transform: initial;
            color: var(--input-current-value-color);
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        a.reset {
            display: inline-block;
            text-transform: uppercase;
            text-decoration: none !important;
            font-size: 0.6em !important;
            letter-spacing: 0.1em;
        }

        /* USER'S GUIDE */
        .users-guide {
            position: fixed;
            top: 0;
            left: 0;
            height: 90vh;
            overflow: scroll;
            width: 40em;
            margin: 5vh 0 0 5vh;
            padding: 1em 4em 2em 2em;
            z-index: 10;
            background-color: var(--users-guide-background-color);
            box-shadow: 0.5em 0.5em 4em var(--users-guide-background-color);
            display: none;
        }
        .close {
            display: block;
            text-decoration: none;
            font-size: 3em;
            position: fixed;
            margin: -1rem 0 0 35rem;
            font-weight: 200;
        }
        h2 {
            font-weight: 300;
            text-transform: uppercase;
            font-size: 1.5em;
            margin-top: 1.5em;
        }

        /* STATUS */
        .status {
            position: fixed;
            right: 0;
            bottom: var(--sidebar-width);
            width: var(--sidebar-width);
            background-color: var(--status-background-color);
            padding: 1em;
            font-size: 0.8em;
            pointer-events: none;
            opacity: 1;
        }
        .status.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background-color: var(--main-background-color);
        }
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
            width: calc(100vw - var(--sidebar-width));
            position: absolute;
        }
        .dropper-text {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 1em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 40%;
            margin: auto;
            margin-top: 20vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }
        #dropped-image, #cropped-image {
            display: none;
        }
        #base-image {
            position: absolute;
        }
        #work {
            position: absolute;
            display: block;
            height: 100vh;
            width: calc(100vw - var(--sidebar-width));
            cursor: crosshair;
        }

        /* OLD CIRCLES TABLE */
        .circles-table-container.hidden {
            display: none;
        }
        .circles-table {
            width: calc(100% + 2em);
            margin-left: -1em;
            border-spacing: 0;
        }
        .circles-table thead {
            text-transform: uppercase;
            font-size: 0.9em;
            font-weight: 900;
        }
        .circles-table tr:hover {
            background-color: var(--input-background-color);
        }
        .circles-table td {
            padding: 0.25rem;
        }
        .circles-table td:first-child {
            padding-left: 1rem;
        }
        .circles-table td:last-child {
            text-align: right;
            padding-right: 1rem;
        }
        .circles-table u {
            font-size: 0.8em;
            font-style: italic;
            text-decoration: none;
            letter-spacing: -0.1em;
        }
        .circles-table span {
            color: #aaa;
            letter-spacing: -0.1em;
        }
        .circles-table button {
            width: auto;
            margin: 0 0 0 -0.2em;
            display: inline-block;
            width: 1.5em;
            height: 1.5em;
            padding: 0.05em 0.3em;
            text-align: center;
            border-radius: 99em;
        }
        .circles-table .delete:hover {
            color: var(--input-danger-color);
        }

        /* TODO clean up position absolute and fixed */

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
            <svg viewBox="0 0 250 250" aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
            </svg>
        </a>
        <h1>
            Cr<svg viewBox="-105 -105 210 210" style="stroke: currentColor; stroke-dasharray: 21 14; stroke-width: 10; fill: none;">
                <path d="M0,0 L70.7,-70.7"></path>
                <circle cx="0" cy="0" r="100" />
            </svg>p
            <em>Circles</em>
        </h1>
        <p>A tool for cropping circular <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery.</p>
        <span><strong>Usage:</strong> Provide an image, click and drag from a center point to make a selection, refine it with <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> <kbd>+</kbd> <kbd>-</kbd>, then press <kbd>enter</kbd> to download the cropped result. <a href="javascript:showUsersGuide();">Learn more…</a></span>

        <section class="circles-table-container hidden">
            <hr>

            <p><span>The following reverse-chronological table lists your old selections within this image, enabling redownloading and deletion.</span></p>

            <table class="circles-table">
                <thead>
                    <td>x →</td>
                    <td>y ↓</td>
                    <td>radius</td>
                    <td></td>
                </thead>
                <tbody id="circles-table-body">
                </tbody>
            </table>
        </section>

        <hr>

        <label><input type="checkbox" class="show-old-selections-checkbox" data-default="yes" onclick="updateShowOldSelections(this);" checked> show old selections</label>
        <span>Shows previously selected circles, which is helpful for keeping track of what you've already done.</span>

        <label>
            <input type="range" min="0.1" max="2.0" step="0.1" value="1.0" data-default="1.0" class="precision-helper-zoom-slider" oninput="adjustPrecisionHelperZoom(this)">
            <br>
            <b>1.0×</b>
            precision helper zoom
        </label>
        <span>Adjusts the zoom level of the thumbnails shown in the precision helper below.</span>

        <label><input type="checkbox" class="download-immediately-checkbox" data-default="yes" onclick="updateDownloadImmediately(this);" checked> download immediately</label>
        <span>Uncheck this if you prefer downloading your images through the table above <em>after</em> making a bunch of selections.</span>

        <input type="text" class="filename-template-field" data-default="" placeholder="FILENAME TEMPLATE" value="" oninput="updateFilenameTemplate(this)">
        <span>Template for the filenames of result images (but don't specify the file extension, it's added automatically). You can look up the list of template variables in <a href="">the user's guide TODO link (should be: sw...ne..., original filename, current time in iso form, circle id, some joke thingy?)</a>. If left empty, the default "cropcircles-x{x}y{y}r{r}" (plus "-{lat},{lon},{rm}m" if the current image <a href="">has geo data TODO link to section of users guide</a>) will be used.</span>

        <hr>

        <label><input type="checkbox" class="transparent-background-checkbox" data-default="yet" onclick="updateTransparentBackground(this);" checked> transparent background</label>
        <span>If <em>un</em>checked, the surroundings of the circular selection will be visible in the corners of the final images – essentially, this turns the selection into a rectangle. You can add some margin with the options below. <!--Also, since in this case there is no need for transparency anymore, the final image will be a JPG instead of a PNG.--></span>

        <section class="margin-settings disabled">
            <label>
                <input type="range" min="0.0" max="4.0" step="0.1" value="0.0" data-default="0.0" class="vertical-margin-slider" oninput="adjustVerticalMargin(this)" disabled>
                <br>
                <b>0·<em>r</em></b>
                vertical margin
            </label>
            <span>Above and below the circular core of the selection, include a vertical margin expressed as a fraction of the selection radius <em>r</em>.</span>

            <label>
                <input type="range" min="0.0" max="4.0" step="0.1" value="0.0" data-default="0.0" class="horizontal-margin-slider" oninput="adjustHorizontalMargin(this)" disabled>
                <br>
                <b>0·<em>r</em></b>
                horizontal margin
            </label>
            <span>Analogous to the vertical margin, but towards the left and right.</span>
        </section>

        <hr>

        <p><span><em>These settings are continually written to local storage and will be restored when you close and reopen this page.</em></span></p>
        <p><span>Nevertheless, TODO write + make these work! also, make them half-width, just cause cool.</span></p>
        <button onclick="downloadSVG();">download settings</button>
        <button onclick="downloadSVG();">restore settings...</button>
        <a class="reset" href="javascript:resetSettings();">reset settings</a>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>
    <footer class="status hidden"></footer>
    <main>
        <img id="base-image">
        <canvas id="work"></canvas>
        <div class="dropper">
            <div class="dropper-text">
                Drop image here
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
    </main>
    <img id="dropped-image">
    <canvas id="cropped-image"></canvas>

    <section class="users-guide">
        <a href="javascript:hideUsersGuide();" class="close">×</a>
        <p><a href="https://github.com/doersino/cropcircles">This</a> is a tool originally designed for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery such as the kind generated by <a href="https://github.com/doersino/aerialbot">ærialbot</a>. <em>(But nothing's keeping you from using it to crop circles from imagery-in-a–more–general–sense.)</em></p>

        <p><span>TODO this is an unabashedly-built-for-me tool, with precisely the options i thought would enable me to fine-tune my workflow (TODO what workflow, what's the result), but I think it might still be useful for others if they care to spend a couple minutes reading this document (or, alternatively, playing around)</span></p>

        <h2>Basic Usage</h2>
        <p>1. Drop an image into the main area.</p>
        <p>2. Click and drag from a center point to make a circular selection.
        <p>3. Keeping an eye on the precision helper in the bottom right, adjust the selection with the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> (or with <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd>); you can increase or decrease the size of your selection with <kbd>+</kbd> <kbd>-</kbd> (or <kbd>P</kbd> <kbd>O</kbd>. Press <kbd>shift</kbd> to adjust in 20× larger increments.</p>
        <p>4. When satisfied, press <kbd>enter</kbd> to accept the selected circle – it will then download as a PNG image, tightly cropped around the x and y bounds of the circle, with transparent corners. (If you wish to cancel the current selection, press <kbd>esc</kbd>.)</p>
        <p>5. Repeat steps 2 through 4 for as many circles as you'd like to select.</p>

        <h2>Configuration</h2>

        <p>TODO</p>

        <h2>Geo-Awareness</h2>
        <p>If the dropped file's filename if of the form TODO with latlon, the cropped circles will be named based on their center point's latitude, longitude and circle radius (that one in meters). This assumes that the aerial imagery you've uploaded is laid out based on a TODO what kinda projection?, which probably isn't true (it's the Web Mercator projection TODO if aerialbot) – but on small scales (sub-10km), it's accurate enough (no less accurate than the "registration" of the imagery, i bet).</p>

        <h2>Notes</h2>

        <p>⦿ TODO keep images below 100 megapixels – things get sluggish fast if you shoot past this limit. then again, i'm using a 5-year-old computer and perhaps not the fastest browser, so ymmv.</p>

        TODO clicking, moving to "resurrect" old selection

        TODO table usage

        <hr>

        <h2>Privacy Policy</h2>
        <p>There isn't any server communication beyond the initial page load, so you should be safe. No analytics or trackers either. This tool is hosted on GitHub Pages, so I don't even have access to web server logs (but presumably, GitHub does).</p>
        <p>But, in the words of the inimitable LeVar Burton, <em>you don't have to take my word for it</em>: Just download this tool (TODO link), disconnect your device from the internet, open the tool in an incognito window, do your work, close the window, delete your local copy of the tool, then enable wifi again.</p>

        <h2>Credit</h2>
        <p>TODO iosevka, TODO inspo project, TODO mddb as base for sidebar, TODO mdn, TODO smaple image from google maps at https://www.google.com/maps/place/42°18'48.7%22N+113°51'19.8%22W/@42.3135278,-113.8576887,6000m/ and dl'd with aerialbot</p>
    </section>

    <script>
        // TODO now, implement:
        // * keep hash of image, along with circles, in local storage. provide means of backing local storage up (button!) and restoring it (mini drag area in sidebar? or just file selection button. or both!). (also wiping, i guess). => then, if user drags in a previously-dragged image, the previously-marked circles will show up
        // * => things to base hash on: filename, width, height, size
        // * => also local storage backup and restore etc., plus settings-only export and import
        // * show warning for mobile users
        // * => as per https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent just check for "Mobi": https://stackoverflow.com/a/24600597
        // * => or show if a touch event is fired? https://developer.mozilla.org/en-US/docs/Web/API/Touch_events
        // * make main drag area also pop up a file selector when clicked: https://stackoverflow.com/a/28075416
        // * make file download async so it wouldn't block?
        // * fix status messages: make async like umml compile status
        // * TODO maybe "download all" (zip?, perhaps with a json file allowing re-import, plus the original image for good measure?) and "delete all" buttons at the bottom of the table

        /////////////
        // GLOBALS //
        /////////////

        let precisionHelper = null;
        let work = null;

        let dpr = 1;
        let scale = null;
        let geoRect = null;

        let currentlySelectingCircle = false;
        let currentCircle = null;

        let highlightedCircleId = null;

        let circles = [];


        /////////////
        // HELPERS //
        /////////////

        // via https://gist.github.com/luciopaiva/01bda0d4311ccaecea0478ad2fd03108
        function readCssVar(name) {
            name = name.startsWith("--") ? name : "--" + name;
            return window.getComputedStyle(document.documentElement).getPropertyValue(name);
        }

        function logicalCanvasToImage(n) {  // for mouse tracking
            return n * dpr / scale;
        }
        function imageToLogicalCanvas(n) {  // for image sizing
            return scale * n / dpr;
        }
        function imageToPhysicalCanvas(n) {  // for selection drawing
            return n * scale;
        }
        function logicalCanvastoPhysicalCanvas(n) {  // primarily for line strength scaling
            return n * dpr;
        }

        function setupCanvas(elem) {

            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels (larger on retina devices)
            let w = elem.offsetWidth;
            let h = elem.offsetHeight;
            elem.style.width = w + "px";
            elem.style.height = h + "px";

            let W = w * dpr;
            let H = h * dpr;
            elem.setAttribute("width", W);
            elem.setAttribute("height", H);

            return {
                elem: elem,
                ctx: elem.getContext("2d"),
                w: w,
                h: h,
                W: W,
                H: H
            }
        }

        //////////////////
        // CANVAS SETUP //
        //////////////////

        function setupPrecisionHelper() {
            let prec = document.getElementById("prec");
            precisionHelper = setupCanvas(prec);
            renderPrecisionHelper();
        }

        function setupWork() {
            work = document.getElementById("work");
            setupCanvas(work);
        }


        ////////////////////
        // IMAGE DROPPING //
        ////////////////////

        document.querySelector('.dropper').addEventListener('dragover', e => {
            e.preventDefault();
        });
        document.querySelector('.dropper').addEventListener('drop', e => {
            e.preventDefault();
            setStatus("Setting up image...", true);

            let files = e.dataTransfer.files;
            if (files.length > 0) {
                // TODO error if more than 1 file? in general, a way of presenting errors nicely?

                let filename = files[0].name;
                extractAndSetGeoRect(filename);
                console.log(files[0]);

                let reader = new FileReader();
                reader.onload = e => {
                    setImage(e.target.result);
                    clearStatus();
                };
                reader.readAsDataURL(files[0]);
            }
        });

        document.querySelector('.load-sample').addEventListener('click', e => {
            e.preventDefault();
            setStatus("Setting up sample image...", true);
            let filename = "sample-sw42.286577541476696,-113.90409924217032ne42.340476458523305,-113.80691475782969.jpg";
            extractAndSetGeoRect(filename);
            setImage(filename);
            clearStatus();
        });

        function setImage(src) {

            // store the image in a hidden img tag
            document.getElementById("dropped-image").addEventListener('load', e => {
                document.querySelector(".dropper").setAttribute("style", "display: none;");
                drawDroppedImage();
            });
            document.getElementById("dropped-image").setAttribute("src", src);
        }

        function drawDroppedImage() {
            let image = document.getElementById("dropped-image");

            let scaleX = work.width / image.width;
            let scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);

            document.getElementById("base-image").setAttribute("src", image.src);
            document.getElementById("base-image").setAttribute("width", imageToLogicalCanvas(image.width))
            document.getElementById("base-image").setAttribute("height", imageToLogicalCanvas(image.height));
        }

        ///////////////////
        // GEO-AWARENESS //
        ///////////////////

        // TODO move this section to a better location?

        function extractAndSetGeoRect(filename) {

            // shoutout to https://regexr.com
            let regex = /sw(-?\d+.\d+),(-?\d+.\d+)ne(-?\d+.\d+),(-?\d+.\d+)/;
            let match = filename.match(regex);
            if (match && match.length == 5) {
                geoRect = {
                    sw: {
                        lat: parseFloat(match[1]),
                        lon: parseFloat(match[2])
                    },
                    ne: {
                        lat: parseFloat(match[3]),
                        lon: parseFloat(match[4])
                    }
                };
            }
        }

        // TODO note: x, y in image space
        // TODO note: actually correct, even for large areas, taken from aerialbot
        // TODO split into toLat and toLon?
        function getLatLon(x, y) {
            let image = document.getElementById("dropped-image");

            // invert y (since image y increases from top to bottom, but latitude increases from bottom to top)
            y = image.height - y;

            // relativize
            x /= image.width;
            y /= image.height;

            let radians = x => x * Math.PI / 180;
            let degrees = x => x * 180 / Math.PI;

            let west = geoRect.sw.lon;
            let east = geoRect.ne.lon;
            let width = east - west;
            if (width < 0) {
                width += 360;
            }
            let lon = west + width * x;
            if (lon > 180) {
                lon -= 360;
            } else if (lon < -180) {
                lon += 360;
            }

            let north = radians(geoRect.ne.lat);
            let south = radians(geoRect.sw.lat);
            let lat = degrees(Math.asin(y * (Math.sin(north) - Math.sin(south)) + Math.sin(south)));

            return {lat: lat, lon: lon};
        }

        // TODO use this for output filename
        function getCenterLatLon() {
            return getLatLon(image.width / 2, image.height / 2);
        }

        // TODO: this is the length of n (image space pixels) in meters at lat,lon
        // TODO refine this. share radians function, remove (also in other places) dependency on .dropped-image (store image size in js)
        function getMeters(lat, lon, n) {
            let image = document.getElementById("dropped-image");
            let earthCircumference = 40075.016686 * 1000;  // in meters, at the equator
            let radians = x => x * Math.PI / 180;
            meters_per_pixel = ((earthCircumference / image.width) * Math.cos(radians(lat))) / (360 / (geoRect.ne.lon - geoRect.sw.lon));
            return meters_per_pixel * n;
        }

        ////////////////////
        // CANVAS DRAWING //
        ////////////////////

        function renderPrecisionHelper() {
            let pc = precisionHelper.ctx;
            let W = precisionHelper.W;
            let H = precisionHelper.H;
            let w = precisionHelper.w;
            let h = precisionHelper.h;

            pc.clearRect(0, 0, W, H);

            pc.lineWidth = logicalCanvastoPhysicalCanvas(1);
            pc.strokeStyle = readCssVar("current-selection-stroke");

            if (currentCircle) {
                let image = document.getElementById("dropped-image");
                let x = currentCircle.startX;
                let y = currentCircle.startY;
                let r = currentCircle.r;

                // TODO make this prettier, maybe it's possible to do all 9 cases in a general function like this?
                function drawImageSquare(xx, yy) {  // x, y from -1, 0, 1
                    let zoom = 1 / precisionHelperZoom;
                    let rad = (xx != 0 && yy != 0) ? (r / Math.sqrt(2)) : r;  // corners
                    pc.drawImage(
                        image,
                        x + (xx * rad) - w/6 * zoom,
                        y + (yy * rad) - h/6 * zoom,
                        w/3 * zoom,
                        h/3 * zoom,
                        (1 + xx) * W/3,
                        (1 + yy) * H/3,
                        W/3,
                        H/3
                        );
                }

                let selectionRadius = r * dpr * precisionHelperZoom;

                // center
                //pc.drawImage(image, x - w/6 * precisionHelperZoom, y - h/6 * precisionHelperZoom, w/3 * precisionHelperZoom, h/3 * precisionHelperZoom, W/3, H/3, W/3, H/3);
                drawImageSquare(0, 0);
                pc.beginPath();
                pc.moveTo(W/2-W/18, H/2-H/18);
                pc.lineTo(W/2-W/72, H/2-H/72);
                pc.moveTo(W/2+W/72, H/2+H/72);
                pc.lineTo(W/2+W/18, H/2+H/18);
                pc.moveTo(W/2+W/18, H/2-H/18);
                pc.lineTo(W/2+W/72, H/2-H/72);
                pc.moveTo(W/2-W/72, H/2+H/72);
                pc.lineTo(W/2-W/18, H/2+H/18);
                pc.rect(W/2, H/2, 0.5 * dpr, 0.5 * dpr);
                pc.stroke();

                // top
                //pc.drawImage(image, x - w/6, y - r - h/6, w/3, h/3, W/3, 0, W/3, H/3);
                drawImageSquare(0, -1);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, H/6 + selectionRadius, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom
                //pc.drawImage(image, x - w/6, y + r - h/6, w/3, h/3, W/3, 2*H/3, W/3, H/3);
                drawImageSquare(0, 1);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, 5*H/6 - selectionRadius, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // left
                //pc.drawImage(image, x - r - w/6, y - h/6, w/3, h/3, 0, H/3, W/3, H/3);
                drawImageSquare(-1, 0);
                pc.save();
                pc.beginPath();
                pc.rect(0, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius, H/2, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // right
                //pc.drawImage(image, x + r - w/6, y - h/6, w/3, h/3, 2*W/3, H/3, W/3, H/3);
                drawImageSquare(1, 0);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius, H/2, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top left
                //pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 0, 0, W/3, H/3);
                drawImageSquare(-1, -1);
                pc.save();
                pc.beginPath();
                pc.rect(0, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius / Math.sqrt(2), H/6 + selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top right
                //pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 0, W/3, H/3);
                drawImageSquare(1, -1);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius / Math.sqrt(2), H/6 + selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom left
                //pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 0, 2*H/3, W/3, H/3);
                drawImageSquare(-1, 1);
                pc.save();
                pc.beginPath();
                pc.rect(0, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius / Math.sqrt(2), 5*H/6 - selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom right
                //pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 2*H/3, W/3, H/3);
                drawImageSquare(1, 1);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius / Math.sqrt(2), 5*H/6 - selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();
            }

            pc.beginPath();
            pc.moveTo(W/3, 0);
            pc.lineTo(W/3, H);
            pc.moveTo(2*W/3, 0);
            pc.lineTo(2*W/3, H);
            pc.moveTo(0, H/3);
            pc.lineTo(W, H/3);
            pc.moveTo(0, 2*H/3);
            pc.lineTo(W, 2*H/3);
            pc.lineWidth = logicalCanvastoPhysicalCanvas(2);
            pc.strokeStyle = readCssVar("precision-helper-dividers-stroke");
            pc.stroke();
        }

        function renderWork() {
            let wc = work.getContext("2d");

            wc.clearRect(0, 0, work.width, work.height);

            if (currentCircle) {
                wc.strokeStyle = readCssVar("current-selection-stroke");

                wc.beginPath();
                wc.setLineDash([logicalCanvastoPhysicalCanvas(6), logicalCanvastoPhysicalCanvas(4)]);
                wc.arc(imageToPhysicalCanvas(currentCircle.startX), imageToPhysicalCanvas(currentCircle.startY), imageToPhysicalCanvas(currentCircle.r), 0, 2 * Math.PI);
                wc.moveTo(imageToPhysicalCanvas(currentCircle.startX), imageToPhysicalCanvas(currentCircle.startY));
                wc.lineTo(imageToPhysicalCanvas(currentCircle.x), imageToPhysicalCanvas(currentCircle.y));
                wc.lineWidth = logicalCanvastoPhysicalCanvas(1);
                wc.stroke();
                wc.setLineDash([]);

                if (!transparentBackground) {
                    wc.beginPath();
                    wc.setLineDash([logicalCanvastoPhysicalCanvas(2), logicalCanvastoPhysicalCanvas(3)]);
                    wc.rect(
                        imageToPhysicalCanvas(currentCircle.startX - (horizontalMargin + 1) * currentCircle.r),
                        imageToPhysicalCanvas(currentCircle.startY - (verticalMargin + 1) * currentCircle.r),
                        imageToPhysicalCanvas((2 * horizontalMargin + 2) * currentCircle.r),
                        imageToPhysicalCanvas((2 * verticalMargin + 2) * currentCircle.r)
                        );
                    wc.stroke();
                    wc.setLineDash([]);
                }
            }

            if (showOldSelections) {
                wc.strokeStyle = readCssVar("old-selections-stroke");
                wc.fillStyle = readCssVar("old-selections-fill");
                circles.forEach(circle => {

                    // don't yet draw the highlighted one
                    if (circle.id != highlightedCircleId) {
                        wc.beginPath();
                        wc.arc(imageToPhysicalCanvas(circle.x), imageToPhysicalCanvas(circle.y), imageToPhysicalCanvas(circle.r), 0, 2 * Math.PI);
                        wc.fill();
                        wc.stroke();
                    }
                });
            }

            if (highlightedCircleId) {
                let circle = getCircle(highlightedCircleId)

                // TODO note: it's possible for the to not be a circle for the passed id iff the user has just deleted a circle through the table in the sidebar – before the table row disappears, the mouseover event is fired at least one more time, calling this function
                if (circle) {
                    wc.strokeStyle = readCssVar("highlighted-selection-stroke");
                    wc.fillStyle = readCssVar("highlighted-selection-fill");

                    wc.beginPath();
                    wc.arc(imageToPhysicalCanvas(circle.x), imageToPhysicalCanvas(circle.y), imageToPhysicalCanvas(circle.r), 0, 2 * Math.PI);
                    wc.fill();
                    wc.stroke();

                    // TODO deduplicate with code above
                    if (!transparentBackground) {
                        wc.beginPath();
                        wc.setLineDash([logicalCanvastoPhysicalCanvas(2), logicalCanvastoPhysicalCanvas(3)]);
                        wc.rect(
                            imageToPhysicalCanvas(circle.x - (horizontalMargin + 1) * circle.r),
                            imageToPhysicalCanvas(circle.y - (verticalMargin + 1) * circle.r),
                            imageToPhysicalCanvas((2 * horizontalMargin + 2) * circle.r),
                            imageToPhysicalCanvas((2 * verticalMargin + 2) * circle.r)
                            );
                        wc.stroke();
                        wc.setLineDash([]);
                    }
                }
            }
        }


        //////////////////////
        // CIRCLE SELECTION //
        //////////////////////

        document.getElementById("work").addEventListener('mousedown', event => {

            // only react when a normal click was performed
            if (event.button != 0) {
                return;
            }

            currentlySelectingCircle = true;
            currentCircle = {
                startX: logicalCanvasToImage(event.pageX),  // - left offset of #work wrt viewport if top left corner of canvas were not at (0,0)
                startY: logicalCanvasToImage(event.pageY),  // analogous
                x: logicalCanvasToImage(event.pageX),
                y: logicalCanvasToImage(event.pageY),
                r: 0
            };
        });
        document.getElementById("work").addEventListener('mousemove', event => {
            if (currentlySelectingCircle) {
                let x = logicalCanvasToImage(event.pageX);  // see caveat above
                let y = logicalCanvasToImage(event.pageY);  // analogous

                let dy = Math.abs(y - currentCircle.startY);
                let dx = Math.abs(x - currentCircle.startX);
                let r = Math.sqrt(dx ** 2 + dy ** 2);

                currentCircle.x = x;
                currentCircle.y = y;
                currentCircle.r = r;
                renderWork();
                renderPrecisionHelper();
            }
        });
        document.getElementById("work").addEventListener('mouseup', event => {

            // only react when a normal click was performed
            if (event.button != 0) {
                return;
            }

            currentlySelectingCircle = false;

            // on click, copy previous selection. currentCircle.r is always set here since it's been initialized in the mousedown event
            if (currentCircle.r == 0 && circles.length > 0) {
                let x = logicalCanvasToImage(event.pageX);  // see caveat above
                let y = logicalCanvasToImage(event.pageY);  // analogous

                cloneMostRecentSelectionAt(x, y);
            }
        });

        // TODO move this function to a better place
        function cloneMostRecentSelectionAt(x, y) {
            let previousCircle = circles[circles.length-1];
            currentCircle = {
                startX: x,
                startY: y,
                x: x + previousCircle.r / Math.sqrt(2),
                y: y - previousCircle.r / Math.sqrt(2),
                r: previousCircle.r
            };
            renderWork();
            renderPrecisionHelper();
        }


        ///////////////////
        // CIRCLES TABLE //
        ///////////////////

        function getCircle(id) {
            return circles.find(c => c.id == id);
        }

        function addToTable(id) {
            document.querySelector(".circles-table-container").classList.remove("hidden");

            let table = document.getElementById("circles-table-body");
            let circle = getCircle(id);

            let lat = "";
            let lon = "";
            let rm = "";
            if (geoRect) {
                let latlon = getLatLon(circle.x, circle.y);
                let m = getMeters(latlon.lat, latlon.lon, circle.r);
                lat = `<span>${(latlon.lat + "").toString().substring(0,8)}°</span>`;
                lon = `<span>${(latlon.lon + "").substring(0,8)}°</span>`;
                rm = `<span>${parseInt(m)}m</span>`;
            }

            let cells = `
                <td>${parseInt(circle.x)}<u>px</u> ${lon}</td>
                <td>${parseInt(circle.y)}<u>px</u> ${lat}</td>
                <td>${parseInt(circle.r)}<u>px</u> ${rm}</td>
                <td>
                    <button onclick="cropAndDownload(${id})">
                        <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                    </button>
                    <button onclick="deleteCircle(${id})" class="delete">
                        <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M-10,-10 L10,10 M-10,10 L10,-10"></path></svg>
                    </button>
                </td>
                `;

            let tr = document.createElement("tr");
            tr.id = id;
            tr.setAttribute("onmouseover", "highlightCircle(" + id + ")");  // would register this with js, but that's almost less elegant than this
            tr.setAttribute("onmouseout", "highlightCircle(null)");
            tr.innerHTML = cells;

            table.insertBefore(tr, table.firstChild);
        }

        function highlightCircle(id) {
            highlightedCircleId = id;
            renderWork();
        }

        function deleteCircle(id) {
            circles = circles.filter(c => c.id != id);
            document.getElementById(id).remove();
            renderWork();
        }


        /////////////////////////
        // CROPPING & DOWNLOAD //
        /////////////////////////

        function assembleFilename(id) {
            let circle = getCircle(id);

            let x = circle.x;
            let y = circle.y;
            let r = circle.r;

            // super basic string variable replacement, via https://stackoverflow.com/a/1408373
            let supplant = (s, o) => {
                return s.replace(/{([^{}]*)}/g,
                    function (a, b) {
                        var r = o[b];
                        return typeof r === 'string' || typeof r === 'number' ? r : a;
                    }
                );
            };

            let filenameVariables = {
                x: parseInt(x),
                y: parseInt(y),
                r: parseInt(r)
            }

            if (geoRect) {
                let latlon = getLatLon(x, y);
                let rm = getMeters(latlon.lat, latlon.lon, circle.r);
                filenameVariables = Object.assign(filenameVariables, {
                    lat: latlon.lat,
                    lon: latlon.lon,
                    rm: rm
                });
            }

            let filename = supplant(filenameTemplate, filenameVariables);

            if (filename == "") {  // this means the template was not set
                let defaultFilenameTemplate = "cropcircles-x{x}y{y}r{r}"
                if (geoRect) {
                    defaultFilenameTemplate += "-{lat},{lon},{rm}m"
                }
                filename = supplant(defaultFilenameTemplate, filenameVariables);
            }

            return filename;
        }

        function cropAndDownload(id) {
            let circle = getCircle(id);

            let x = circle.x;
            let y = circle.y;
            let r = circle.r;

            let filename = assembleFilename(id);

            let imageType = "image/png";
            let imageQuality = 1;
            let imageExtension = ".png";
            if (!transparentBackground) {
                imageType = "image/jpeg";
                imageExtension = ".jpg";
            }

            let width = Math.ceil(r * 2);
            let height = Math.ceil(r * 2);
            if (!transparentBackground) {
                width += 2 * r * horizontalMargin;
                height += 2 * r * verticalMargin;
            }

            let image = document.getElementById("dropped-image");
            let croppedImage = document.getElementById("cropped-image");

            croppedImage.setAttribute("width", width);
            croppedImage.setAttribute("height", height);

            let cic = croppedImage.getContext("2d");
            cic.clearRect(0, 0, width, height);

            if (!transparentBackground) {
                cic.drawImage(image, x - r - r * horizontalMargin, y - r - r * verticalMargin, width, height, 0, 0, width, height);
            }
            else {
                cic.save();
                cic.beginPath();
                cic.arc(r, r, r, 0, 2 * Math.PI);
                cic.closePath();
                cic.clip();
                cic.drawImage(image, x - r, y - r, width, height, 0, 0, width, height);
                cic.restore();
            }

            croppedImage.toBlob(blob => {
                let url = URL.createObjectURL(blob);
                let dummyLink = document.createElement("a");
                dummyLink.setAttribute("href", url);
                dummyLink.setAttribute("download", filename + imageExtension);
                dummyLink.style.display = "none";
                document.body.appendChild(dummyLink);
                dummyLink.click();
                document.body.removeChild(dummyLink);

                URL.revokeObjectURL(url);
            }, imageType, imageQuality);
        }


        //////////////////////////
        // KEYBOARD INTERACTION //
        //////////////////////////

        function acceptCurrentCircle() {
            setStatus("Cropping image...", true);

            let circle = {
                id: Date.now(),
                x: currentCircle.startX,
                y: currentCircle.startY,
                r: currentCircle.r
            };
            circles.push(circle);
            currentCircle = null;

            addToTable(circle.id);
            if (downloadImmediately) {
                cropAndDownload(circle.id);
            }

            renderWork();
            renderPrecisionHelper();

            clearStatus();
        }

        function cancelCurrentCircle() {
            currentCircle = null;
            renderWork();
            renderPrecisionHelper();
        }

        function scaleCurrentCircle(s) {
            currentCircle.r += s;
            if (currentCircle.r < 0) {
                currentCircle.r = 0;
            }

            // this took some figuring out!
            let f = currentCircle.r / (currentCircle.r - s);
            currentCircle.x = currentCircle.startX + (currentCircle.x - currentCircle.startX) * f;
            currentCircle.y = currentCircle.startY + (currentCircle.y - currentCircle.startY) * f;

            renderWork();
            renderPrecisionHelper();
        }

        // TODO do nothing if there is not current circle (to avoid console errors more than anything) – the same goes for related functions
        function moveCurrentCircle(x, y) {

            // TODO comment: selection cloning on move: move it by 2r
            if (!currentCircle && circles.length > 0) {
                let circle = circles[circles.length-1];
                let x0 = circle.x + Math.sign(x) * 2 * circle.r;
                let y0 = circle.y + Math.sign(y) * 2 * circle.r;
                cloneMostRecentSelectionAt(x0, y0);
            }

            currentCircle.startX += x;
            currentCircle.startY += y;
            currentCircle.x += x;
            currentCircle.y += y;

            renderWork();
            renderPrecisionHelper();
        }

        // TODO only enable this once image has been dropped and a selection has been made?
        window.addEventListener("keydown", function (event) {
            // TODO disable this if the focus is on one of the inputs in the sidebar – interferes with filename input, possibly others too!

            let factor = 1;
            let larger = 20;
            if (event.shiftKey) {
                factor = larger;
            }

            switch (event.key) {
                case "Enter":
                    acceptCurrentCircle();
                    break;
                case "Escape":
                    cancelCurrentCircle();
                    break;

                case "ArrowUp":
                case "w":
                case "W":
                    moveCurrentCircle(0, -factor);
                    break;
                case "ArrowDown":
                case "s":
                case "S":
                    moveCurrentCircle(0, factor);
                    break;
                case "ArrowLeft":
                case "a":
                case "A":
                    moveCurrentCircle(-factor, 0);
                    break;
                case "ArrowRight":
                case "d":
                case "D":
                    moveCurrentCircle(factor, 0);
                    break;

                case "+":
                case "p":
                case "P":
                    scaleCurrentCircle(factor);
                    break;
                case "*":  // "shift +" on the German keyboard layout i use
                    scaleCurrentCircle(larger);
                    break;
                case "-":
                case "o":
                case "O":
                    scaleCurrentCircle(-factor);
                    break;
                case "_":  // "shift -" on the German keyboard layout i use
                    scaleCurrentCircle(-larger);
                    break;

                default:
                  return;  // quit when we don't want to handle the key event
              }

              // TODO switch based on .code ("KeyW", etc.) for wasd. how to handle default case above then?

            // cancel the default action to avoid it being handled twice
            event.preventDefault();
        }, true);


        /////////////////////
        // WINDOW RESIZING //
        /////////////////////

        // TODO future changes to setupWork and drawDroppedImage might break this. safeguard agains this through abstraction or documentation!
        window.addEventListener('resize', () => {
            let h = window.innerHeight
            let w = window.innerWidth - document.querySelector(".sidebar").offsetWidth;

            let workElem = document.getElementById("work");

            workElem.style.width = w + "px";
            workElem.style.height = h + "px";
            setupWork();

            drawDroppedImage();  // this sets scale

            renderWork();
        });


        ////////////
        // STATUS //
        ////////////

        // helper function for displaying status messages
        function setStatus(message, persist) {
            let status = document.querySelector(".status");
            status.innerHTML = message;
            status.className = "status";
            if (!persist) {
                setTimeout(clearStatus, 500);
            }
        }

        // helper function for hiding the current status message
        function clearStatus() {
            let status = document.querySelector(".status");
            status.className = "status hidden";
        }


        ////////////
        // CONFIG //
        ////////////

        let showOldSelections = true;
        let showOldSelectionsCheckbox = document.querySelector(".show-old-selections-checkbox");
        let precisionHelperZoom = 1;
        let precisionHelperZoomSlider = document.querySelector(".precision-helper-zoom-slider");
        let downloadImmediately = true;
        let downloadImmediatelyCheckbox = document.querySelector(".download-immediately-checkbox");
        let filenameTemplate = "";
        let filenameTemplateField = document.querySelector(".filename-template-field");

        let transparentBackground = true;
        let transparentBackgroundCheckbox = document.querySelector(".transparent-background-checkbox");
        let marginSettings = document.querySelector(".margin-settings");
        let verticalMargin = 0;
        let verticalMarginSlider = document.querySelector(".vertical-margin-slider");
        let horizontalMargin = 0;
        let horizontalMarginSlider = document.querySelector(".horizontal-margin-slider");

        // process config, restore settings from local storage if existant
        function setupConfig() {

            // restore settings from local storage
            if (showOldSelections = window.localStorage.getItem("show-old-selections")) {
                showOldSelectionsCheckbox.checked = showOldSelections == "yes";
            }
            updateShowOldSelections(showOldSelectionsCheckbox);

            if (precisionHelperZoom = window.localStorage.getItem("precision-helper-zoom")) {
                precisionHelperZoomSlider.value = precisionHelperZoom;
            }
            adjustPrecisionHelperZoom(precisionHelperZoomSlider);

            if (downloadImmediately = window.localStorage.getItem("download-immediately")) {
                downloadImmediatelyCheckbox.checked = downloadImmediately == "yes";
            }
            updateDownloadImmediately(downloadImmediatelyCheckbox);

            if (filenameTemplate = window.localStorage.getItem("filename-template")) {
                filenameTemplateField.value = filenameTemplate;
            }
            updateFilenameTemplate(filenameTemplateField);

            if (transparentBackground = window.localStorage.getItem("transparent-background")) {
                transparentBackgroundCheckbox.checked = transparentBackground == "yes";
            }
            updateTransparentBackground(transparentBackgroundCheckbox);

            if (verticalMargin = window.localStorage.getItem("vertical-margin")) {
                verticalMarginSlider.value = verticalMargin;
            }
            adjustVerticalMargin(verticalMarginSlider);

            if (horizontalMargin = window.localStorage.getItem("horizontal-margin")) {
                horizontalMarginSlider.value = horizontalMargin;
            }
            adjustHorizontalMargin(horizontalMarginSlider);
        }

        function updateShowOldSelections(checkbox) {
            showOldSelections = !!checkbox.checked;
            window.localStorage.setItem("show-old-selections", !!checkbox.checked ? "yes" : "no");
            renderWork();
        }

        function adjustPrecisionHelperZoom(slider) {
            precisionHelperZoom = parseFloat(slider.value);
            precisionHelperZoomSlider.parentNode.querySelector("b").innerHTML = precisionHelperZoom + "×";
            window.localStorage.setItem("precision-helper-zoom", precisionHelperZoom);
            renderPrecisionHelper();
        }

        function updateDownloadImmediately(checkbox) {
            downloadImmediately = !!checkbox.checked;
            window.localStorage.setItem("download-immediately", !!checkbox.checked ? "yes" : "no");
        }

        function updateFilenameTemplate(field) {
            filenameTemplate = field.value;
            window.localStorage.setItem("filename-template", filenameTemplate);
        }

        function updateTransparentBackground(checkbox) {
            transparentBackground = !!checkbox.checked;
            window.localStorage.setItem("transparent-background", !!checkbox.checked ? "yes" : "no");
            if (transparentBackground) {
                marginSettings.classList.add("disabled");
                verticalMarginSlider.disabled = true;
                horizontalMarginSlider.disabled = true;
            } else {
                marginSettings.classList.remove("disabled");
                verticalMarginSlider.disabled = false;
                horizontalMarginSlider.disabled = false;
            }
            renderWork();
        }

        function adjustVerticalMargin(slider) {
            verticalMargin = parseFloat(slider.value);
            verticalMarginSlider.parentNode.querySelector("b").innerHTML = verticalMargin + "·<em>r</em>";
            window.localStorage.setItem("vertical-margin", verticalMargin);
            renderWork();
        }

        function adjustHorizontalMargin(slider) {
            horizontalMargin = parseFloat(slider.value);
            horizontalMarginSlider.parentNode.querySelector("b").innerHTML = horizontalMargin + "·<em>r</em>";
            window.localStorage.setItem("horizontal-margin", horizontalMargin);
            renderWork();
        }

        function resetSettings() {
            showOldSelectionsCheckbox.checked = showOldSelectionsCheckbox.getAttribute("data-default");
            updateShowOldSelections(showOldSelectionsCheckbox);
            precisionHelperZoomSlider.value = precisionHelperZoomSlider.getAttribute("data-default");
            adjustPrecisionHelperZoom(precisionHelperZoomSlider);
            downloadImmediatelyCheckbox.checked = downloadImmediatelyCheckbox.getAttribute("data-default");
            updateDownloadImmediately(downloadImmediatelyCheckbox);
            filenameTemplateField.value = filenameTemplateField.getAttribute("data-default");
            updateFilenameTemplate(filenameTemplateField);

            transparentBackgroundCheckbox.checked = transparentBackgroundCheckbox.getAttribute("data-default");
            updateTransparentBackground(transparentBackgroundCheckbox);
            verticalMarginSlider.value = verticalMarginSlider.getAttribute("data-default");
            adjustVerticalMargin(verticalMarginSlider);
            horizontalMarginSlider.value = horizontalMarginSlider.getAttribute("data-default");
            adjustHorizontalMargin(horizontalMarginSlider);
        }


        //////////////////
        // USER'S GUIDE //
        //////////////////

        // TODO build way of showing it if not already visible and scrolling to a specific section
        function showUsersGuide() {
            document.querySelector(".users-guide").setAttribute("style", "display: block;");
        }

        function hideUsersGuide() {
            document.querySelector(".users-guide").setAttribute("style", "display: none;");
        }


        ////////////////////////////////////
        // IT'S LIGHTS OUT AND AWAY WE GO //
        ////////////////////////////////////

        if (window.devicePixelRatio) {
            dpr = window.devicePixelRatio;
        }

        setupPrecisionHelper();
        setupWork();

        setupConfig();
    </script>
</body>
</html>
