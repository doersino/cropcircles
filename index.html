<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" lang="en">
    <title>Crop Circles</title>
    <link rel="stylesheet" href="libs/ttf-iosevka-aile-3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --status-background-color: #444;

            --precision-helper-background-color: #000;

            --main-background-color: #131313;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --dropper-background-color: #555;
            --dropper-color: #aaa;


            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem
        }
        button, label, input[type="text"], select {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem
        }
        button:hover, label:hover, input[type="text"]:hover, label:hover select {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        select {
            margin-top: 0.3em;
            text-transform: none;
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            font-weight: normal;
            float: right;
            color: var(--input-current-value-color);
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        a.reset {
            display: inline-block;
            text-transform: uppercase;
            text-decoration: none !important;
            font-size: 0.6em !important;
            letter-spacing: 1px;
        }

        /* STATUS */
        footer {
            position: fixed;
            right: 0;
            bottom: var(--sidebar-width);
            width: var(--sidebar-width);
            background-color: var(--status-background-color);
            padding: 1em;
            font-size: 0.8em;
            pointer-events: none;
            opacity: 1;
        }
        footer.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background-color: var(--main-background-color);
        }
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
            width: calc(100vw - var(--sidebar-width));
            position: absolute;
        }
        .dropper-text {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 1em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 40%;
            margin: auto;
            margin-top: 20vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }
        #dropped-image, #cropped-image {
            display: none;
        }
        #base-image {
            position: absolute;
        }
        #work {
            position: absolute;
            display: block;
            height: 100vh;
            width: calc(100vw - var(--sidebar-width));
            cursor: crosshair;
        }

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
            <svg viewBox="0 0 250 250" aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
            </svg>
        </a>
        <h1><em>Crop</em> Circles</h1>
        <p>A tool for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery. <a href="https://github.com/doersino/cropcircles#readme">Learn more…</a></p>

        <hr>

        <label><input type="checkbox" class="show-old-selections-checkbox" data-default="yes" onclick="updateShowOldSelections(this);" checked> show old selections</label>
        <span>Show previously selected circles to help you keep track of what you've already done.</span>

        <label>
            image background<br>
            <select class="zoom-level-slider" oninput="adjustZoomLevel(this.value)">
                <option value="transparent">Transparent</option>
                <option value="black">White</option>
                <option value="white">Black</option>
                <option value="keep-image-background">Keep Image Background</option>
            </select>
        </label>
        <span>TODO dropdown for background color: transparent, black, white, image content</span>

        <span>TODO zoom slider for precision helper: from 0.5x to 2x? would need to adjust cropped section of image, also radius accordingly</span>

        <span>TODO checkbox: include surroundings. implies image background "keep", includes 1/2 the radius around the selection. during circle drawing, show dotted preview of rect.</span>

        <!--<button onclick="copySource(this);">copy source<b></b></button>
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <input type="text" placeholder="Location">
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <button onclick="downloadSVG();">download svg<b></b></button>
        <span>Handy for inserting your diagram into a non-Markdeep document. <em>Includes the source in a &lt;metadata&gt; tag.</em></span>

        <hr>

        <label><input type="checkbox" onclick="toggleDarkMode(this);" data-default="light" class="dark-mode-checkbox"> dark mode</label>

        <label>
            <input type="range" min="0.5" max="3.0" step="0.01" value="1.0" data-default="1.0" class="zoom-level-slider" oninput="adjustZoomLevel(this.value)">
            <br>zoom level <b>100%</b>
        </label>
        <span>Scales both source and preview.</span>

        <label>
            <input type="range" min="1.00" max="1.50" step="0.01" value="1.25" data-default="1.25" class="line-height-slider" oninput="adjustLineHeight(this.value)">
            <br>line height <b>1.25em</b>
        </label>
        <label>
            <input type="range" min="-0.30" max="0.45" step="0.01" value="0.15" data-default="0.15" class="letter-spacing-slider" oninput="adjustLetterSpacing(this.value)">
            <br>letter spacing <b>0.15px</b>
        </label>
        <span>Both of the above might need adjusting depending on your zoom level, browser and installed fonts.</span>-->

        <hr>

        <p><span><em>These settings are continually written to local storage and will be restored when you close and reopen this page.</em></span></p>
        <a class="reset" href="javascript:resetSettings();">reset settings</a>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>
    <footer class="hidden"></footer>
    <main>
        <img id="base-image">
        <canvas id="work"></canvas>
        <div class="dropper">
            <div class="dropper-text">
                Drop image here
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
    </main>
    <img id="dropped-image">
    <canvas id="cropped-image"></canvas>

    <section class="users-guide" style="position: fixed; top: 0; left: 0; height: 90vh; overflow: scroll; max-width: 40em; margin: 5vh; padding: 1em 2em 2em; z-index: 10; background-color: #111;">
        <h1><a href="" style="text-decoration: none;">×</a></h1><br>
        <p><a href="https://github.com/doersino/cropcircles">This</a> is a tool originally designed for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery such as the kind generated by <a href="https://github.com/doersino/aerialbot">ærialbot</a>. <em>(But nothing's keeping you from using it to crop circles from imagery-in-a–more–general–sense.)</em></p>

        <h2 style="font-weight: 300; text-transform: uppercase;">Basic Usage</h2>
        <p>1. Drop an image into the main area.</p>
        <p>2. Click and drag from a center point to make a circular selection.
        <p>3. Keeping an eye on the precision helper in the bottom right, adjust the selection like a gamer via <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd>; you can zoom in with <kbd>O</kbd> and out via <kbd>P</kbd>. Press <kbd>shift</kbd> to adjust in 10× larger increments.</p>
        <p>4. When satisfied, press <kbd>enter</kbd> to accept the selected circle – it will then download as a PNG image, tightly cropped around the bounds of the circle. TODO note how the corners are transparent (If you wish to cancel the current selection, press <kbd>esc</kbd>.)</p>

        <h2 style="font-weight: 300; text-transform: uppercase;">CONFIGURATION</h2>

        <p>TODO</p>

        <h2 style="font-weight: 300; text-transform: uppercase;">PRIVACY</h2>
        <p>There's no server communication beyond the initial loading, so you should be safe.</p>
        <p>But don't take my word for it: Just download this tool (TODO link), turn off your wifi, open the tool, do your work, close the tab, delete your local copy of the tool, then enable wifi again.</p>
    </section>

    <script src="https://code.jquery.com/jquery-latest.js" crossorigin="anonymous"></script>
    <script>
        // TODO now, implement:
        // * maybe a list in the sidebar, with a re-download possibility?
        // * think of additional, more useful settings
        // * stroke colors from css variables, or js variables
        // * maybe get latlon from filename somehow? would need nw and se in there. then also have (linearly interpolated, no need to be fancy at these scales) latlon in output filename.
        // * on click, insert a circle the size of the previous circle? that could get around mi/km selection necessity
        // * similarly, on move or resize immediately after accepting a circle (i.e. before starting to draw a new one), make a copy of the just-accepted one and proceed with that
        // * maybe support for browser resizing, but that's a buncha work for zero benefit in practice. otherwise, show a warning on resize?
        // * make main drag area also pop up a file selector when clicked: https://stackoverflow.com/a/28075416

        // shower thoughts:
        // TODO option: include surroundings. (replaces backgroudn drowpdown) slider: horiz distance to incldue in *r, vertical distance to include in *r => include background, emit jpg, display box preview during circle selecting
        // TODO option: don't immediately downlaod upon selction acceptance
        // TODO clicking on prev circles redownloads them with current settings
        // TODO keep hash of image, along with circles, in local storage. provide means of backing local storage up (button!) and restoring it (mini drag area in sidebar? or just file selection button. or both!). (also wiping, i guess). => then, if user drags in a previously-dragged image, the previously-marked circles will show up. might then need a way of removing circles? hover and backspace? maybe highlight circles on hover

        /////////////
        // GLOBALS //
        /////////////

        let dpr = 1;
        let scale = null;

        let precisionHelper = null;
        let work = null;

        let currentlySelectingCircle = false;
        let currentCircle = null;

        let circles = [];


        /////////////
        // HELPERS //
        /////////////

        function logicalCanvasToImage(n) {  // for mouse tracking
            return n * dpr / scale;
        }
        function imageToLogicalCanvas(n) {  // for image sizing
            return scale * n / dpr;
        }
        function imageToPhysicalCanvas(n) {  // for selection drawing
            return n * scale;
        }
        function logicalCanvastoPhysicalCanvas(n) {  // primarily for line strength scaling
            return n * dpr;
        }

        function setupCanvas(elem) {

            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels (larger on retina devices)
            let w = elem.offsetWidth;
            let h = elem.offsetHeight;
            elem.style.width = w + "px";
            elem.style.height = h + "px";

            let W = w * dpr;
            let H = h * dpr;
            elem.setAttribute("width", W);
            elem.setAttribute("height", H);

            return {
                elem: elem,
                ctx: elem.getContext("2d"),
                w: w,
                h: h,
                W: W,
                H: H
            }
        }

        //////////////////
        // CANVAS SETUP //
        //////////////////

        function setupPrecisionHelper() {
            let prec = document.getElementById("prec");
            precisionHelper = setupCanvas(prec);
            renderPrecisionHelper();
        }

        function setupWork() {
            work = document.getElementById("work");
            setupCanvas(work);
        }


        ////////////////////
        // IMAGE DROPPING //
        ////////////////////

        $('.dropper')
            .on('dragover', (e) => {
                e.preventDefault();
            })
            .on('drop', (e) => {
                e.preventDefault();
                setStatus("Setting up image...", true);

                let files = e.originalEvent.dataTransfer.files;
                if (files.length > 0) {

                    // TODO error if more than 1 file?
                    let reader = new FileReader();
                    reader.onload = e => {
                        setImage(e.target.result);
                        clearStatus();
                    };
                    reader.readAsDataURL(files[0]);
                }
            });

        $('.load-sample')
            .on('click', (e) => {
                e.preventDefault();
                setStatus("Setting up sample image...", true);
                setImage("sample.jpg");
                clearStatus();
            });

        function setImage(src) {

            // store the image in a hidden img tag
            $("#dropped-image")
                .load(() => {
                    $(".dropper").hide();
                    drawDroppedImage();
                })
                .attr("src", src);
        }

        function drawDroppedImage() {
            let image = document.getElementById("dropped-image");

            let scaleX = work.width / image.width;
            let scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);

            $("#base-image")
                .attr("src", image.src)
                .attr("width", imageToLogicalCanvas(image.width))
                .attr("height", imageToLogicalCanvas(image.height));
        }

        ////////////////////
        // CANVAS DRAWING //
        ////////////////////

        function renderPrecisionHelper() {
            let pc = precisionHelper.ctx;
            let W = precisionHelper.W;
            let H = precisionHelper.H;
            let w = precisionHelper.w;
            let h = precisionHelper.h;

            pc.clearRect(0, 0, W, H);

            pc.lineWidth = logicalCanvastoPhysicalCanvas(1);
            pc.strokeStyle = "#fff";

            if (currentCircle) {
                let image = document.getElementById("dropped-image");
                let x = currentCircle.startX;
                let y = currentCircle.startY;
                let r = currentCircle.r;

                // center
                pc.drawImage(image, x - w/6, y - h/6, w/3, h/3, W/3, H/3, W/3, H/3);
                pc.beginPath();
                pc.moveTo(W/2-W/18, H/2-H/18);
                pc.lineTo(W/2-W/72, H/2-H/72);
                pc.moveTo(W/2+W/72, H/2+H/72);
                pc.lineTo(W/2+W/18, H/2+H/18);
                pc.moveTo(W/2+W/18, H/2-H/18);
                pc.lineTo(W/2+W/72, H/2-H/72);
                pc.moveTo(W/2-W/72, H/2+H/72);
                pc.lineTo(W/2-W/18, H/2+H/18);
                pc.rect(W/2, H/2, 1, 1);
                pc.stroke();

                // top
                pc.drawImage(image, x - w/6, y - r - h/6, w/3, h/3, W/3, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, H/6 + r * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom
                pc.drawImage(image, x - w/6, y + r - h/6, w/3, h/3, W/3, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, 5*H/6 - r * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // left
                pc.drawImage(image, x - r - w/6, y - h/6, w/3, h/3, 0, H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r * dpr, H/2, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // right
                pc.drawImage(image, x + r - w/6, y - h/6, w/3, h/3, 2*W/3, H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r * dpr, H/2, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top left
                pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 0, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r/Math.sqrt(2) * dpr, H/6 + r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top right
                pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r/Math.sqrt(2) * dpr, H/6 + r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom left
                pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 0, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r/Math.sqrt(2) * dpr, 5*H/6 - r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom right
                pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r/Math.sqrt(2) * dpr, 5*H/6 - r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();
            }

            pc.beginPath();
            pc.moveTo(W/3, 0);
            pc.lineTo(W/3, H);
            pc.moveTo(2*W/3, 0);
            pc.lineTo(2*W/3, H);
            pc.moveTo(0, H/3);
            pc.lineTo(W, H/3);
            pc.moveTo(0, 2*H/3);
            pc.lineTo(W, 2*H/3);
            pc.lineWidth = logicalCanvastoPhysicalCanvas(2);
            pc.strokeStyle = "#555";
            pc.stroke();
        }

        function renderWork() {
            let wc = work.getContext("2d");

            wc.clearRect(0, 0, work.width, work.height);  // TODO do this more neatly or is it neat enough?

            if (currentCircle) {
                // TODO does it make more sense to store these values globally, for adjustment via keyboard shortcuts? probably!

                wc.beginPath();
                wc.setLineDash([logicalCanvastoPhysicalCanvas(6), logicalCanvastoPhysicalCanvas(4)]);
                wc.arc(imageToPhysicalCanvas(currentCircle.startX), imageToPhysicalCanvas(currentCircle.startY), imageToPhysicalCanvas(currentCircle.r), 0, 2 * Math.PI);
                wc.moveTo(imageToPhysicalCanvas(currentCircle.startX), imageToPhysicalCanvas(currentCircle.startY));
                wc.lineTo(imageToPhysicalCanvas(currentCircle.x), imageToPhysicalCanvas(currentCircle.y));
                wc.lineWidth = logicalCanvastoPhysicalCanvas(1);
                wc.strokeStyle = "#fff";
                wc.stroke();
                wc.setLineDash([]);
            }

            if (showOldSelections) {
                circles.forEach(circle => {
                    wc.beginPath();
                    wc.arc(circle.x * scale, circle.y * scale, circle.r * scale, 0, 2 * Math.PI);
                    wc.fillStyle = "rgba(255,255,255,0.2)";
                    wc.fill();
                    wc.strokeStyle = "rgba(255,255,255,0.5)";
                    wc.stroke();
                });
            }
        }

        $("#work")
            .mousedown((event) => {
                currentlySelectingCircle = true;
                currentCircle = {
                    startX: logicalCanvasToImage(event.pageX),  // - $("#work").offset().left if top left corner of canvas is not at (0,0)
                    startY: logicalCanvasToImage(event.pageY),  // analogous
                    x: logicalCanvasToImage(event.pageX),
                    y: logicalCanvasToImage(event.pageY),
                    r: 0
                };
            })
            .mousemove((event) => {
                if (currentlySelectingCircle) {
                    x = logicalCanvasToImage(event.pageX);
                    y = logicalCanvasToImage(event.pageY);

                    let dy = Math.abs(y - currentCircle.startY);
                    let dx = Math.abs(x - currentCircle.startX);
                    r = Math.sqrt(dx ** 2 + dy ** 2);

                    currentCircle.x = x;
                    currentCircle.y = y;
                    currentCircle.r = r;
                    renderWork();
                    renderPrecisionHelper();
                }
            })
            .mouseup((event) => {
                currentlySelectingCircle = false;
            });


        /////////////////////////
        // CROPPING & DOWNLOAD //
        /////////////////////////

        function cropAndDownload(circle) {
            let x = circle.x;
            let y = circle.y;
            let r = circle.r;

            width = Math.ceil(r * 2);
            height = Math.ceil(r * 2);

            let image = document.getElementById("dropped-image");
            let croppedImage = document.getElementById("cropped-image");
            croppedImage.setAttribute("width", width);
            croppedImage.setAttribute("height", height);
            let cic = croppedImage.getContext("2d");
            cic.clearRect(0, 0, width, height);
            cic.save();
            cic.beginPath();
            cic.arc(r, r, r, 0, 2 * Math.PI);
            cic.closePath();
            cic.clip();
            cic.drawImage(image, x - r, y - r, width, height, 0, 0, width, height);
            cic.restore();

            croppedImage.toBlob(blob => {
                let url = URL.createObjectURL(blob)

                let dummyLink = document.createElement("a");
                dummyLink.setAttribute("href", url);
                dummyLink.setAttribute("download", "cropcircles-x" + parseInt(x) + "y" + parseInt(y) + "r" + parseInt(r) + ".png");
                dummyLink.style.display = "none";
                document.body.appendChild(dummyLink);
                dummyLink.click();
                document.body.removeChild(dummyLink);

                URL.revokeObjectURL(url);
            }, "image/png");
        }


        //////////////////////////
        // KEYBOARD INTERACTION //
        //////////////////////////

        function acceptCurrentCircle() {
            setStatus("Cropping image...", true);

            circles.push({
                x: currentCircle.startX,
                y: currentCircle.startY,
                r: currentCircle.r
            });
            currentCircle = null;
            cropAndDownload(circles[circles.length-1]);

            renderWork();
            renderPrecisionHelper();

            clearStatus();
        }

        function cancelCurrentCircle() {
            currentCircle = null;
            renderWork();
            renderPrecisionHelper();
        }

        function scaleCurrentCircle(s) {
            currentCircle.r += s;

            // this took some figuring out!
            let f = currentCircle.r / (currentCircle.r - s);
            currentCircle.x = currentCircle.startX + (currentCircle.x - currentCircle.startX) * f;
            currentCircle.y = currentCircle.startY + (currentCircle.y - currentCircle.startY) * f;

            renderWork();
            renderPrecisionHelper();
        }

        function moveCurrentCircle(x, y) {
            currentCircle.startX += x;
            currentCircle.startY += y;
            currentCircle.x += x;
            currentCircle.y += y;

            renderWork();
            renderPrecisionHelper();
        }

        // TODO only enable this once image has been dropped and a selection has been made?
        $(document)
            .keydown(event => {
                let factor = 1;
                if (event.shiftKey) {
                    factor = 20;
                }

                // TODO use this: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
                // => then switch back to arrow keys and +/-, or at least add them as options (if keeping wasd+op, use .char instead of key)
                //console.log(event.which);

                if (event.which == 13) {
                    event.preventDefault();
                    acceptCurrentCircle();
                } else if (event.which == 27) {
                    event.preventDefault();
                    cancelCurrentCircle();
                } else if (event.which == 87) {  // W
                    event.preventDefault();
                    moveCurrentCircle(0, -factor);
                } else if (event.which == 83) {  // S
                    event.preventDefault();
                    moveCurrentCircle(0, factor);
                } else if (event.which == 65) {  // A
                    event.preventDefault();
                    moveCurrentCircle(-factor, 0);
                } else if (event.which == 68) {  // D
                    event.preventDefault();
                    moveCurrentCircle(factor, 0);
                } else if (event.which == 79) {  // O
                    event.preventDefault();
                    scaleCurrentCircle(-factor);
                } else if (event.which == 80) {  // P
                    event.preventDefault();
                    scaleCurrentCircle(factor);
                }
            });


        ////////////
        // STATUS //
        ////////////

        // helper function for displaying status messages
        function setStatus(message, persist) {
            let status = document.querySelector("footer");
            status.innerHTML = message;
            status.className = "";
            if (!persist) {
                setTimeout(clearStatus, 500);
            }
        }

        // helper function for hiding the current status message
        function clearStatus() {
            let status = document.querySelector("footer");
            status.className = "hidden";
        }


        ////////////
        // CONFIG //
        ////////////

        let showOldSelections = true;
        let showOldSelectionsCheckbox = document.querySelector(".show-old-selections-checkbox");

        // process config, restore settings from local storage if existant
        function setupConfig() {

            // restore settings from local storage
            if (showOldSelections = window.localStorage.getItem("show-old-selections")) {
                showOldSelectionsCheckbox.checked = showOldSelections == "yes";
                updateShowOldSelections(showOldSelectionsCheckbox);
            } else {
                updateShowOldSelections(showOldSelectionsCheckbox);
                // TODO not sure why that's required since the variable is set to true.
                // but if this line is not run: on first load with no local storage set yet, old circs don't show up until the checkbox is toggled twice
            }

            // TODO more settings
        }

        function updateShowOldSelections(checkbox) {
            showOldSelections = !!checkbox.checked;
            window.localStorage.setItem("show-old-selections", !!checkbox.checked ? "yes" : "no");
            renderWork();  // TODO but only if image has already been dropped
        }

        function resetSettings() {
            showOldSelectionsCheckbox.checked = showOldSelectionsCheckbox.getAttribute("data-default");
            updateShowOldSelections(showOldSelectionsCheckbox);
        }

        function nukeLocalStorage() {
            localStorage.removeItem("show-old-selections");
        }


        ////////////////////////////////////
        // IT'S LIGHTS OUT AND AWAY WE GO //
        ////////////////////////////////////

        $(document).ready(() => {
            if (window.devicePixelRatio) {
                dpr = window.devicePixelRatio;
            }

            setupPrecisionHelper();
            setupWork();

            setupConfig();
        });
    </script>
</body>
</html>
