<html class="light">
<head>
    <meta charset="utf-8" lang="en">
    <title>Crop Circles</title>
    <link rel="stylesheet" href="libs/ttf-iosevka-aile-3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --status-background-color: #444;

            --precision-helper-background-color: #000;

            --main-background-color: #131313;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --dropper-background-color: #555;
            --dropper-color: #aaa;


            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem
        }
        button, label, input[type="text"], select {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem
        }
        button:hover, label:hover, input[type="text"]:hover, label:hover select {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        select {
            margin-top: 0.3em;
            text-transform: none;
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            font-weight: normal;
            float: right;
            color: var(--input-current-value-color);
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        a.reset {
            display: inline-block;
            text-transform: uppercase;
            text-decoration: none !important;
            font-size: 0.6em !important;
            letter-spacing: 1px;
        }

        /* STATUS */
        footer {
            position: fixed;
            right: 0;
            bottom: var(--sidebar-width);
            width: var(--sidebar-width);
            background-color: var(--status-background-color);
            padding: 1em;
            font-size: 0.8em;
            pointer-events: none;
            opacity: 1;
        }
        footer.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background-color: var(--main-background-color);
        }
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
            width: calc(100vw - var(--sidebar-width));
            position: absolute;
        }
        .dropper-text {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 1em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 40%;
            margin: auto;
            margin-top: 20vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }
        #dropped-image, #cropped-image {
            display: none;
        }
        #base-image {
            position: absolute;
        }
        #work {
            position: absolute;
            display: block;
            height: 100vh;
            width: calc(100vw - var(--sidebar-width));
            cursor: crosshair;
        }

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
            <svg viewBox="0 0 250 250" aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
            </svg>
        </a>
        <h1><em>Crop</em> Circles</h1>
        <p>A tool for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery. <a href="https://github.com/doersino/cropcircles#readme">Learn more…</a></p>

        <span><strong>Usage:</strong> Drop an image into the main area. Click and drag from a center point to make a circular selection. Keeping an eye on the precision helper in the bottom right, adjust the selection via the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd>; you can zoom in or out via <kbd>+</kbd> and <kbd>-</kbd>. Press <kbd>shift</kbd> to adjust in 10× larger increments. When satisfied, press <kbd>enter</kbd> to accept the selected circle – it will then download as a PNG image. If you wish to cancel the current selection, press <kbd>esc</kbd>.</span>

        <hr>

        <label><input type="checkbox" class="show-old-selections-checkbox" data-default="yes" onclick="updateShowOldSelections(this);" checked> show old selections</label>
        <span>Show previously selected circles to help you keep track of what you've already done.</span>

        <label>
            image background<br>
            <select class="zoom-level-slider" oninput="adjustZoomLevel(this.value)">
                <option value="transparent">Transparent</option>
                <option value="black">White</option>
                <option value="white">Black</option>
                <option value="keep-image-background">Keep Image Background</option>
            </select>
        </label>
        <span>TODO dropdown for background color: transparent, black, white, image content</span>

        <span>TODO zoom slider for precision helper: from 0.5x to 2x? would need to adjust cropped section of image, also radius accordingly</span>

        <span>TODO checkbox: include surroundings. implies image background "keep", includes 1/2 the radius around the selection</span>

        <!--<button onclick="copySource(this);">copy source<b></b></button>
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <input type="text" placeholder="Location">
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <button onclick="downloadSVG();">download svg<b></b></button>
        <span>Handy for inserting your diagram into a non-Markdeep document. <em>Includes the source in a &lt;metadata&gt; tag.</em></span>

        <hr>

        <label><input type="checkbox" onclick="toggleDarkMode(this);" data-default="light" class="dark-mode-checkbox"> dark mode</label>

        <label>
            <input type="range" min="0.5" max="3.0" step="0.01" value="1.0" data-default="1.0" class="zoom-level-slider" oninput="adjustZoomLevel(this.value)">
            <br>zoom level <b>100%</b>
        </label>
        <span>Scales both source and preview.</span>

        <label>
            <input type="range" min="1.00" max="1.50" step="0.01" value="1.25" data-default="1.25" class="line-height-slider" oninput="adjustLineHeight(this.value)">
            <br>line height <b>1.25em</b>
        </label>
        <label>
            <input type="range" min="-0.30" max="0.45" step="0.01" value="0.15" data-default="0.15" class="letter-spacing-slider" oninput="adjustLetterSpacing(this.value)">
            <br>letter spacing <b>0.15px</b>
        </label>
        <span>Both of the above might need adjusting depending on your zoom level, browser and installed fonts.</span>-->

        <hr>

        <p><span><em>These settings are continually written to local storage and will be restored when you close and reopen this page.</em></span></p>
        <a class="reset" href="javascript:resetSettings();">reset settings</a>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>
    <footer class="hidden"></footer>
    <main>
        <img id="base-image">
        <canvas id="work"></canvas>
        <div class="dropper">
            <div class="dropper-text">
                Drop image here
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
    </main>
    <img id="dropped-image">
    <canvas id="cropped-image">

    <script src="https://code.jquery.com/jquery-latest.js" crossorigin="anonymous"></script>
    <script>
        // TODO now, implement:
        // * move stuff to render function based on image (maybe drawn below canvas), old circles, current in-progress circle
        // * keeping around of old circles in an organized manner, and visually distinct from current cirle (fill? gray?)
        // * adjustments of circles via keyboard and acceptance
        // * then, perform the actual cropping and downloading
        // * maybe a list in the sidebar, with a re-download possibility?
        // * stroke colors from css variables, or js variables
        // * code cleanup
        // * think of additional, more useful settings
        // * maybe support for browser resizing, but that's a buncha work for zero benefit in practice

        // TODO show warning on resize event




        function setupCanvas(elem) {

            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels (larger on retina devices)
            var w = elem.offsetWidth;
            var h = elem.offsetHeight;
            var dpr = 1;
            var W, H;
            if (window.devicePixelRatio) {
                dpr = window.devicePixelRatio;
                elem.style.width = w + "px";
                elem.style.height = h + "px";
                W = w * dpr;
                H = h * dpr;
            }
            elem.setAttribute("width", W);
            elem.setAttribute("height", H);

            return {
                elem: elem,
                ctx: elem.getContext("2d"),
                w: w,
                h: h,
                W: W,
                H: H,
                dpr: dpr
            }
        }

        function setupPrecisionHelper() {
            let prec = document.getElementById("prec");
            let precisionHelper = setupCanvas(prec);
            renderPrecisionHelper(precisionHelper);
            return precisionHelper;
        }

        function renderPrecisionHelper(precisionHelper) {
            let pc = precisionHelper.ctx;
            let W = precisionHelper.W;
            let H = precisionHelper.H;
            let w = precisionHelper.w;
            let h = precisionHelper.h;

            pc.clearRect(0, 0, W, H);

            pc.lineWidth = 1 * dpr;
            pc.strokeStyle = "#fff";

            if (currentCircle) {
                var image = document.getElementById("dropped-image");
                let x = currentCircle.startX * dpr / scale;
                let y = currentCircle.startY * dpr / scale;
                let r = currentCircle.r * dpr / scale;

                // center
                pc.drawImage(image, x - w/6, y - h/6, w/3, h/3, W/3, H/3, W/3, H/3);
                pc.beginPath();
                pc.moveTo(W/2-W/18, H/2-H/18);
                pc.lineTo(W/2-W/72, H/2-H/72);
                pc.moveTo(W/2+W/72, H/2+H/72);
                pc.lineTo(W/2+W/18, H/2+H/18);
                pc.moveTo(W/2+W/18, H/2-H/18);
                pc.lineTo(W/2+W/72, H/2-H/72);
                pc.moveTo(W/2-W/72, H/2+H/72);
                pc.lineTo(W/2-W/18, H/2+H/18);
                pc.rect(W/2, H/2, 1, 1);
                pc.stroke();

                // top
                pc.drawImage(image, x - w/6, y - r - h/6, w/3, h/3, W/3, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, H/6 + r * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom
                pc.drawImage(image, x - w/6, y + r - h/6, w/3, h/3, W/3, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, 5*H/6 - r * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // left
                pc.drawImage(image, x - r - w/6, y - h/6, w/3, h/3, 0, H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r * dpr, H/2, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // right
                pc.drawImage(image, x + r - w/6, y - h/6, w/3, h/3, 2*W/3, H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r * dpr, H/2, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top left
                pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 0, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r/Math.sqrt(2) * dpr, H/6 + r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top right
                pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r/Math.sqrt(2) * dpr, H/6 + r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom left
                pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 0, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r/Math.sqrt(2) * dpr, 5*H/6 - r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom right
                pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r/Math.sqrt(2) * dpr, 5*H/6 - r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();
            }

            pc.beginPath();
            pc.moveTo(W/3, 0);
            pc.lineTo(W/3, H);
            pc.moveTo(2*W/3, 0);
            pc.lineTo(2*W/3, H);
            pc.moveTo(0, H/3);
            pc.lineTo(W, H/3);
            pc.moveTo(0, 2*H/3);
            pc.lineTo(W, 2*H/3);
            pc.lineWidth = 2 * dpr;
            pc.strokeStyle = "#555";
            pc.stroke();
        }

        function setupWork() {

        }

        let dpr = 1;
        if (window.devicePixelRatio) {
            dpr = window.devicePixelRatio;
        }

        let precisionHelper = setupPrecisionHelper();

        let work = document.getElementById("work");
        let wcanv = setupCanvas(work);
        let wc = work.getContext("2d");
        let scale = 1;

        var currentlySelectingCircle = false;
        var currentCircle = null;

        var circles = [];



        $('.dropper')
            .on('dragover', (e) => {
                e.preventDefault();
            })
            .on('drop', (e) => {
                e.preventDefault();
                setStatus("Setting up image...", true);

                let files = e.originalEvent.dataTransfer.files;
                if (files.length > 0) {

                    // TODO error if more than 1 file?
                    let reader = new FileReader();
                    reader.onload = (e) => {

                        // store the image in a hidden img tag
                        $("#dropped-image")
                            .load(() => {
                                $(".dropper").hide();
                                drawDroppedImage();
                                clearStatus();

                            })
                            .attr("src", e.target.result);
                    };
                    reader.readAsDataURL(files[0]);
                }
            });

        $('.load-sample')
            .on('click', (e) => {
                e.preventDefault();
                setStatus("Setting up image...", true)

                $("#dropped-image")
                    .load(() => {
                        $(".dropper").hide();
                        drawDroppedImage();
                        clearStatus();
                    })
                    .attr("src", "sample.jpg");
            });

        function drawDroppedImage() {
            var image = document.getElementById("dropped-image");

            var scaleX = work.width / image.width;
            var scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);

            $("#base-image")
                .attr("src", image.src)
                .attr("width", scale * image.width / dpr)  // TODO work.width / dpr?
                .attr("height", scale * image.height / dpr);  // TODO work.height / dpr?
        }

        function renderWork() {
            wc.clearRect(0, 0, work.width, work.height);  // TODO do this more neatly or is it neat enough?

            if (currentCircle) {
                // TODO does it make more sense to store these values globally, for adjustment via keyboard shortcuts? probably!

                wc.beginPath();
                wc.setLineDash([6*dpr, 4*dpr]);
                wc.arc(currentCircle.startX * dpr, currentCircle.startY * dpr, currentCircle.r * dpr, 0, 2 * Math.PI);
                wc.moveTo(currentCircle.startX * dpr, currentCircle.startY * dpr);
                wc.lineTo(currentCircle.x * dpr, currentCircle.y * dpr);
                wc.lineWidth = 1 * dpr;
                wc.strokeStyle = "#fff";
                wc.stroke();
                wc.setLineDash([]);
            }

            if (showOldSelections) {
                circles.forEach(circle => {
                    wc.beginPath();
                    wc.arc(circle.x * scale, circle.y * scale, circle.r * scale, 0, 2 * Math.PI);
                    wc.fillStyle = "rgba(255,255,255,0.2)";
                    wc.fill();
                    wc.strokeStyle = "rgba(255,255,255,0.5)";
                    wc.stroke();
                });
            }
        }

        $("#work")
            .mousedown((event) => {
                currentlySelectingCircle = true;
                currentCircle = {
                    startX: event.pageX,  // - $("#work").offset().left if top left corner of canvas is not at (0,0)
                    startY: event.pageY,  // analogous
                    x: event.pageX,
                    y: event.pageY,
                    r: 0
                };
            })
            .mousemove((event) => {
                if (currentlySelectingCircle) {
                    x = event.pageX;
                    y = event.pageY;

                    var dy = Math.abs(y - currentCircle.startY);
                    var dx = Math.abs(x - currentCircle.startX);
                    r = Math.sqrt(dx ** 2 + dy ** 2);

                    currentCircle.x = x;
                    currentCircle.y = y;
                    currentCircle.r = r;
                    renderWork();
                    renderPrecisionHelper(precisionHelper);  // TODO get rid of this argument
                }
            })
            .mouseup((event) => {
                currentlySelectingCircle = false;
            });

        function logicalCanvasToPhysicalCanvas(n) {
            return n * dpr;
        }
        function physicalCanvasToImage(n) {
            return n / scale;
        }
        function imageToPhysicalCanvas(n) {
            return n * scale;
        }
        function physicalCanvasToLogicalCanvas(n) {
            return n / dpr;
        }
        // TODO composition, or jsut define the ones i actually need
        // TODO note that keeping all points etc. in image space will allow easy resizing of canvas if needed
        // TODO need: logical to image (mouse tracking), image to physical (circle drawing), logical to physical (drawing of lines in precision helper), ...?

        function acceptCurrentCircle() {
            setStatus("Cropping image...", true);
            if (currentCircle.x != currentCircle.startX && currentCircle.y != currentCircle.startY) {
                cropAndDownload(currentCircle.startX * dpr / scale, currentCircle.startY * dpr / scale, currentCircle.r * dpr / scale);

                circles.push({
                    x: currentCircle.startX * dpr / scale,
                    y: currentCircle.startY * dpr / scale,
                    r: currentCircle.r * dpr / scale
                });
                currentCircle = null;

                renderWork();
                renderPrecisionHelper(precisionHelper);
            }
            clearStatus();
        }

        function scaleCurrentCircle(s) {
            currentCircle.r += s;

            // TODO what to do with x, y?
            currentCircle.x += s;
            currentCircle.y += s;

            renderWork();
            renderPrecisionHelper(precisionHelper);
        }

        // TODO translation/scaling should happen in image space, not canvas space! would it make sense, then, to store the current circle in image space? perhaps with angle instead of x,y to make scaling easier?
        // TODO => just implement the projection functions already!
        function moveCurrentCircle(x, y) {
            currentCircle.startX += x;
            currentCircle.startY += y;
            currentCircle.x += x;
            currentCircle.y += y;

            renderWork();
            renderPrecisionHelper(precisionHelper);
        }

        // TODO only enable this once image has been dropped and a selection has been made
        $(document)
            .keydown(event => {
                let factor = 1;
                if (event.shiftKey) {
                    factor = 10;
                }

                console.log(event.which);

                if (event.which == 13) {
                    event.preventDefault();
                    acceptCurrentCircle();
                } else if (event.which == 87) {  // W
                    event.preventDefault();
                    moveCurrentCircle(0, -factor);
                } else if (event.which == 83) {  // S
                    event.preventDefault();
                    moveCurrentCircle(0, factor);
                } else if (event.which == 65) {  // A
                    event.preventDefault();
                    moveCurrentCircle(-factor, 0);
                } else if (event.which == 68) {  // D
                    event.preventDefault();
                    moveCurrentCircle(factor, 0);
                } else if (event.which == 81) {  // Q
                    event.preventDefault();
                    scaleCurrentCircle(-factor);
                } else if (event.which == 69) {  // E
                    event.preventDefault();
                    scaleCurrentCircle(factor);
                }
                // TODO + 107??, - 109??, esc 27
            });

        function cropAndDownload(x, y, r) {
            // TODO separate, hidden canvas for cropping. init it with correct size, then set cropping mask depending on option, then write image section to it, then download (with sensible filename)
            width = r * 2;
            height = r * 2;

            var elem = document.getElementById("cropped-image");
            var image = document.getElementById("dropped-image");
            elem.setAttribute("width", width);
            elem.setAttribute("height", height);
            var ctx = elem.getContext("2d");
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.beginPath();
            ctx.arc(r, r, r, 0, 2 * Math.PI);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(image, x - r, y - r, width, height, 0, 0, width, height);
            ctx.restore();

            elem.toBlob(blob => {
                let url = URL.createObjectURL(blob)

                var dummyLink = document.createElement("a");
                dummyLink.setAttribute("href", url);
                dummyLink.setAttribute("download", "cropcircles-x" + x + "y" + y + "r" + r + ".png");
                dummyLink.style.display = "none";
                document.body.appendChild(dummyLink);
                dummyLink.click();
                document.body.removeChild(dummyLink);

                URL.revokeObjectURL(url);
            }, "image/png");
        }


        // helper function for displaying status messages
        function setStatus(message, persist) {
            var status = document.querySelector("footer");
            status.innerHTML = message;
            status.className = "";
            if (!persist) {
                setTimeout(clearStatus, 500);
            }
        }

        function clearStatus() {
            var status = document.querySelector("footer");
            status.className = "hidden";
        }

        var showOldSelections = true;
        var showOldSelectionsCheckbox = document.querySelector(".show-old-selections-checkbox");

        // set up canvases and restore settings from local storage
        function setup() {

            // restore settings from local storage
            if (showOldSelections = window.localStorage.getItem("show-old-selections")) {
                showOldSelectionsCheckbox.checked = showOldSelections == "yes";
                updateShowOldSelections(showOldSelectionsCheckbox);
            } else {
                updateShowOldSelections(showOldSelectionsCheckbox);
                // TODO not sure why that's required since the variable is set to true.
                // but if this line is not run: on first load with no local storage set yet, old circs don't show up until the checkbox is toggled twice
            }

            // TODO more
        }
        setup();

        function updateShowOldSelections(checkbox) {
            showOldSelections = !!checkbox.checked;
            window.localStorage.setItem("show-old-selections", !!checkbox.checked ? "yes" : "no");
            renderWork();  // TODO but only if image has already been dropped
        }

        function resetSettings() {
            showOldSelectionsCheckbox.checked = showOldSelectionsCheckbox.getAttribute("data-default");
            updateShowOldSelections(showOldSelectionsCheckbox);
        }

        function nukeLocalStorage() {
            localStorage.removeItem("show-old-selections");
        }
    </script>
</body>
</html>
