<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" lang="en">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Crop Circles</title>
    <!-- TODO remove unneeded weights etc. -->
    <link rel="stylesheet" href="libs/ttf-iosevka-aile-3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        :root {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --users-guide-background-color: #111;

            --status-background-color: #333;
            --error-background-color: #400;

            --precision-helper-background-color: #000;

            --main-background-color: #131313;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --danger-color: orangered;

            --dropper-background-color: #555;
            --dropper-color: #aaa;
            --another-image-dropper-background-color: #333;
            --another-image-dropper-color: #aaa;

            --current-selection-stroke: #fff;
            --old-selections-stroke: rgba(255,255,255,0.5);
            --old-selections-fill: rgba(255,255,255,0.2);
            --highlighted-selection-stroke: rgba(255,255,255,0.8);
            --highlighted-selection-fill: rgba(255,255,255,0.4);

            --circles-table-geodata-color: #aaa;

            --precision-helper-dividers-stroke: #555;
        }
        html {
            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        h1 svg {
            height: 0.75em;
            margin: 0 -0.05em 0 0.05em;
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        button, label, input[type="text"] {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem
        }
        button:hover, label:hover, input[type="text"]:hover {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button {
            cursor: pointer;
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        input[type="checkbox"] {
            height: 1.25em;
            margin-right: 0.3em;
            vertical-align: text-bottom;  /* hack to make it look vertically centered in chrome but doesn't in firefox... hmm */
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"] {
            text-transform: none;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            float: right;
            font-weight: normal;
            text-transform: initial;
            color: var(--input-current-value-color);
        }
        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .backup-restore {
            display: flex;
        }
        .backup-restore button {
            margin: 0;
        }
        .backup-restore button:first-child {
            display: inline-block;
            width: 13em;
        }
        .backup-restore button:last-child {
            display: inline-block;
            width: 100%;
            margin-left: 0.5em;
        }
        .reset {
            text-transform: uppercase;
            font-size: 0.67em;
            letter-spacing: 0.1em;
        }
        .reset a {
            text-decoration: none;
        }
        .reset a:hover {
            background-color: var(--danger-color);
            color: var(--text-color);
        }

        /* ANOTHER IMAGE DROPPER */
        .another-image-dropper {
            margin: 1rem 0;
            border: 0.15rem dashed var(--another-image-dropper-color);
            border-radius: 1em;
            color: var(--another-image-dropper-color);
            background-color: var(--another-image-dropper-background-color);
            font-size: 1.4em;
            padding: 1rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
            cursor: pointer;
        }
        .another-image-dropper.active {
            background-color: inherit;
            filter: invert(1);
        }
        .another-image-dropper.hidden {
            display: none;
        }

        /* OLD CIRCLES TABLE */
        .circles-table-container.hidden {
            display: none;
        }
        .circles-table {
            width: calc(100% + 2em);
            margin-left: -1em;
            border-spacing: 0;
        }
        .circles-table thead {
            text-transform: uppercase;
            font-size: 0.9em;
            font-weight: 900;
        }
        .circles-table tr:hover {
            background-color: var(--input-background-color);
        }
        .circles-table tfoot span {
            font-style: italic;
        }
        .circles-table td {
            padding: 0.25rem;
        }
        .circles-table td:first-child {
            padding-left: 1rem;
        }
        .circles-table td:last-child {
            text-align: right;
            padding-right: 1rem;
        }
        .circles-table u {
            font-size: 0.8em;
            font-style: italic;
            text-decoration: none;
            letter-spacing: -0.1em;
        }
        .circles-table span {
            color: var(--circles-table-geodata-color);
            letter-spacing: -0.1em;
        }
        .circles-table button {
            width: auto;
            margin: 0 0 0 -0.2em;
            display: inline-block;
            width: 1.5em;
            height: 1.5em;
            padding: 0.05em 0.3em;
            text-align: center;
            border-radius: 99em;
        }
        .circles-table .delete:hover {
            color: var(--danger-color);
        }

        /* USER'S GUIDE */
        .users-guide {
            position: fixed;
            top: 0;
            left: 0;
            height: 90vh;
            overflow: scroll;
            width: 40em;
            margin: 5vh 0 0 5vh;
            padding: 1em 4em 2em 2em;
            z-index: 10;
            background-color: var(--users-guide-background-color);
            box-shadow: 0.5em 0.5em 4em var(--users-guide-background-color);
            display: none;
        }
        .users-guide .hide {
            display: block;
            text-decoration: none;
            font-size: 3em;
            position: fixed;
            margin: -1rem 0 0 35rem;
            font-weight: 200;
        }
        h2 {
            font-weight: 300;
            text-transform: uppercase;
            font-size: 1.5em;
            margin-top: 1.5em;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* STATUS */
        .status {
            position: fixed;
            left: 0;
            bottom: 0;
            background-color: var(--status-background-color);
            padding: 0.5em;
            pointer-events: none;
            z-index: 10;
            opacity: 1;
        }
        .status.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* ERRORS */
        .error {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2em 5em 2em 2em;
            background-color: var(--error-background-color);
            z-index: 10;
        }
        .error-message {
            margin: 0;
        }
        .error .dismiss {
            display: block;
            text-decoration: none;
            font-size: 3em;
            position: fixed;
            right: 2rem;
            margin-top: -1.4rem;
            font-weight: 200;
        }
        .error.hidden {
            display: none;
        }

        /* MAIN CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background-color: var(--main-background-color);
        }
        #dropped-image, #cropped-image {
            display: none;
        }
        #base-image {
            position: absolute;
        }
        #work {
            position: absolute;
            display: block;
            height: 100vh;
            width: calc(100vw - var(--sidebar-width));
            cursor: crosshair;
        }

        /* MAIN DROPPER */
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
            width: calc(100vw - var(--sidebar-width));
            position: absolute;
        }
        .dropper-label {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 1em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 50%;
            margin: auto;
            margin-top: 25vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .dropper.active .dropper-label {
            background-color: inherit;
            filter: invert(1);
        }
        .drop-or-select {
            display: block;
            font-style: normal;
            cursor: pointer;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
            <svg viewBox="0 0 250 250" aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
            </svg>
        </a>
        <h1>
            Cr<svg viewBox="-105 -105 210 210" style="stroke: currentColor; stroke-dasharray: 21 14; stroke-width: 10; fill: none;">
                <path d="M0,0 L70.7,-70.7"></path>
                <circle cx="0" cy="0" r="100" />
            </svg>p
            <em>Circles</em>
        </h1>
        <p>A tool for cropping circular <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery.</p>
        <span><strong>Usage:</strong> Provide an image, click and drag from a center point to make a selection, refine it with <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> <kbd>+</kbd> <kbd>-</kbd>, then press <kbd>enter</kbd> to download the cropped result. <a href="javascript:showUsersGuide();">Learn more…</a></span>

        <input id="upload-another-image" type="file" accept="image/*" style="display: none;">
        <div class="another-image-dropper">
            Drop or <a>select</a> another image…
        </div>
        TODO implement this

        <section class="circles-table-container hidden">
            <hr>

            <p><span>The following reverse-chronological table lists your selections within this image, enabling redownloading (with different settings, say) and deletion.</span></p>

            <table class="circles-table">
                <thead>
                    <td>x →</td>
                    <td>y ↓</td>
                    <td>radius</td>
                    <td></td>
                </thead>
                <tbody id="circles-table-body"></tbody>
                <tfoot id="circles-table-foot"></tfoot>
            </table>

            <button onclick="cropAndDownloadAll();">download all as zip</button>
            TODO set class and attribute .disabled if circles variable is empty
        </section>

        <hr>

        <label><input type="checkbox" class="show-old-selections-checkbox" data-default="yes" onclick="updateShowOldSelections(this);" checked> show old selections</label>
        <span>Shows previously selected circles, which is helpful for keeping track of what you've already done.</span>

        <label>
            <input type="range" min="0.1" max="2.0" step="0.1" value="1.0" data-default="1.0" class="precision-helper-zoom-slider" oninput="adjustPrecisionHelperZoom(this)">
            <br>
            <b>1.0×</b>
            precision helper zoom
        </label>
        <span>Adjusts the zoom level of the thumbnails shown in the precision helper below.</span>

        <label><input type="checkbox" class="download-immediately-checkbox" data-default="yes" onclick="updateDownloadImmediately(this);" checked> download immediately</label>
        <span>Uncheck this if you prefer downloading your images through the table above <em>after</em> making a bunch of selections.</span>

        <input type="text" class="filename-template-field" data-default="" placeholder="FILENAME TEMPLATE" value="" oninput="updateFilenameTemplate(this)">
        <span>Template for the filenames of result images (but don't specify the file extension, it's added automatically). You can look up the list of template variables in <a href="">the user's guide TODO link (should be: sw…ne…, original filename, current time in iso form, circle id, some joke thingy?)</a>. If left empty, the default "cropcircles-x{x}y{y}r{r}" (plus "-{lat},{lon},{rm}m" if the current image <a href="">has geo data TODO link to section of users guide</a>) will be used.</span>

        <hr>

        <label><input type="checkbox" class="transparent-background-checkbox" data-default="yes" onclick="updateTransparentBackground(this);" checked> transparent background</label>
        <span>If <em>un</em>checked, the surroundings of the circular selection will be visible in the corners of the final images – essentially, this turns the selection into a rectangle. You can add some margin with the options below. <!--Also, since in this case there is no need for transparency anymore, the final image will be a JPG instead of a PNG.--></span>

        <section class="margin-settings disabled">
            <label>
                <input type="range" min="0.0" max="4.0" step="0.1" value="0.0" data-default="0.0" class="vertical-margin-slider" oninput="adjustVerticalMargin(this)" disabled>
                <br>
                <b>0·<em>r</em></b>
                vertical margin
            </label>
            <span>Above and below the circular core of the selection, include a vertical margin expressed as a fraction of the selection radius <em>r</em>.</span>

            <label>
                <input type="range" min="0.0" max="4.0" step="0.1" value="0.0" data-default="0.0" class="horizontal-margin-slider" oninput="adjustHorizontalMargin(this)" disabled>
                <br>
                <b>0·<em>r</em></b>
                horizontal margin
            </label>
            <span>Analogous to the vertical margin, but towards the left and right.</span>
            <label>
                <b class="aspect-ratio">1:1</b>
                aspect ratio
            </label>
            <span>Your settings result in the aspect ratio shown above.</span>
        </section>

        <hr>

        <p><span>These <em>settings</em> are continually written to your browser's <em>local storage</em>, so they will likely be restored when you close and reopen this page – but that's up to your browser's caching policies. You can back them up here and restore a previous backup:</span></p>

        <!--for input: https://stackoverflow.com/a/26878895-->
        <section class="backup-restore">
            <button onclick="downloadSettings();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                back up
            </button>
            <input id="upload-settings" type="file" accept="application/json" style="display: none;">
            <button onclick="restoreSettings();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,10 L0,-10 M-10,0 L0,-10 L10,0"></path></svg>
                restore…
            </button>
        </section>
        <p><span>The same goes for your <em>selections</em>, both your current ones and ones you've made in previous sessions. This allows you to close this tool mid-work, reopen it, drag the same image in again, and continue selecting from where you left off – or a different image <a>covering an area</a> you've previously made selections in. Again, your browser might decide to evict this data from its cache, hence:</span></p>
        <section class="backup-restore">
            <button onclick="downloadSelectionCache();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                back up
            </button>
            <input id="upload-selectioncache" type="file" accept="application/json" style="display: none;">
            <button onclick="restoreSelectionCache();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,10 L0,-10 M-10,0 L0,-10 L10,0"></path></svg>
                restore…
            </button>
        </section>

        <hr>

        <span class="reset">
            <strong>Danger zone:</strong> <a href="javascript:resetSettingsToDefaults();">reset settings</a> or <a href="javascript:purgeSelectionCache();">purge selection cache</a>, in which case only your current selections will remain, or <a href="javascript:deleteAllCircles();">delete all current selections</a>.
        </span>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>

    <main>
        <img id="base-image">
        <canvas id="work"></canvas>
        <div class="dropper">
            <div class="dropper-label">
                <input id="upload-image" type="file" accept="image/*" style="display: none;">
                <em class="drop-or-select">Drop or <a>select</a> image…</em>
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
    </main>

    <img id="dropped-image">
    <canvas id="cropped-image"></canvas>

    <footer class="status hidden"></footer>
    <footer class="error hidden">
        <a href="javascript:dismissError();" class="dismiss">×</a>
        <p class="error-message"></p>
    </footer>

    <section class="users-guide">
        <a href="javascript:hideUsersGuide();" class="hide">×</a>
        <p><a href="https://github.com/doersino/cropcircles">This</a> is a tool originally designed for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery such as the kind generated by <a href="https://github.com/doersino/aerialbot">ærialbot</a>. <em>(But nothing's keeping you from using it to crop circles from imagery-in-a–more–general–sense.)</em></p>

        <p><span>TODO this is an unabashedly-built-for-me tool, with precisely the options i thought would enable me to fine-tune my workflow (TODO what workflow, what's the result), but I think it might still be useful for others if they care to spend a couple minutes reading this document (or, alternatively, playing around)</span></p>

        <h2>Basic Usage</h2>
        <p>1. Drop an image into the main area.</p>
        <p>2. Click and drag from a center point to make a circular selection.
        <p>3. Keeping an eye on the precision helper in the bottom right, adjust the selection with the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> (or with <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd>); you can increase or decrease the size of your selection with <kbd>+</kbd> <kbd>-</kbd> (or <kbd>P</kbd> <kbd>O</kbd>. Press <kbd>shift</kbd> to adjust in 20× larger increments.</p>
        <p>4. When satisfied, press <kbd>enter</kbd> to accept the selected circle – it will then download as a PNG image, tightly cropped around the x and y bounds of the circle, with transparent corners. (If you wish to cancel the current selection, press <kbd>esc</kbd>.)</p>
        <p>5. Repeat steps 2 through 4 for as many circles as you'd like to select.</p>

        <h2>Configuration</h2>

        The settings in the sidebar... TODO

        <p>TODO</p>

        <h2>Geo-Awareness</h2>
        <p>If the dropped file's filename if of the form TODO with latlon, the cropped circles will be named based on their center point's latitude, longitude and circle radius (that one in meters). This assumes that the aerial imagery you've uploaded is laid out based on a TODO what kinda projection?, which probably isn't true (it's the Web Mercator projection TODO if aerialbot) – but on small scales (sub-10km), it's accurate enough (no less accurate than the "registration" of the imagery, i bet).</p>

        <h2>Notes</h2>

        <p>⦿ TODO keep images below 100 megapixels – things get sluggish fast if you shoot past this limit. then again, i'm using a 5-year-old computer and perhaps not the fastest browser, so ymmv.</p>

        TODO clicking, moving to "resurrect" old selection

        TODO table usage

        <hr>

        <h2>Privacy Policy</h2>
        <p>There isn't any server communication beyond the initial page load, so you should be safe. No analytics or trackers either. This tool is hosted on GitHub Pages, so I don't even have access to web server logs (but presumably, GitHub does).</p>
        <p>Since your settings and selection cache are kept in local storage, other pages you load though the same protocol-domain-port combination may access them, however that's probably not worth worrying about.</p>
        <p>But, in the words of the inimitable LeVar Burton, <em>you don't have to take my word for it</em>: Just download this tool (TODO link), disconnect your device from the internet, open the tool in an incognito window, do your work, close the window, delete your local copy of the tool, then enable wifi again.</p>

        <h2>Credit</h2>
        <p>TODO iosevka, TODO inspo project, TODO mddb as base for sidebar, TODO mdn, TODO smaple image from google maps at https://www.google.com/maps/place/42°18'48.7%22N+113°51'19.8%22W/@42.3135278,-113.8576887,6000m/ and dl'd with aerialbot</p>
    </section>

    <script src="libs/Stuk-jszip-25d401e/dist/jszip.min.js"></script>
    <script>
        // TODO now, implement:
        // * way of switching to another image. drag area at the top of the sidebar, need to adjust scale, geoRect, currentlySelectingCircle, currentCircle, circles, query selectionCache, etc.
        // * finish user's guide, link to it from various settings, etc. take screenshots & record bits of video?
        // * improve code quality
        /*
            i.e.:
            * stop referring to selections as circles
            * maybe share the svg files document-wide: https://css-tricks.com/svg-use-with-external-reference-take-2/
            * abstract a bit, move some functions around into proper sections
            * keep some references to some important elements globally
            * generally, use classes and ids more sensibly
            * simplify table rendering code: just rerender each time? would make things easier. also, explicitly order by id (descending)?
        */
        // * clean up position absolute and fixed in css

        /////////////
        // GLOBALS //
        /////////////

        let precisionHelper = null;
        let work = null;

        let dpr = 1;
        let scale = null;
        let geoRect = null;

        let currentlySelectingCircle = false;
        let currentCircle = null;

        let highlightedCircleId = null;

        let circles = [];

        let selectionCache = [];
        let relevantGeoSelections = [];

        let imageInfo = {
            name: null,
            size: null,
            width: null,
            height: null,
            fileid: null
        };


        /////////////
        // HELPERS //
        /////////////

        // via https://gist.github.com/luciopaiva/01bda0d4311ccaecea0478ad2fd03108
        function readCssVar(name) {
            name = name.startsWith("--") ? name : "--" + name;
            return window.getComputedStyle(document.documentElement).getPropertyValue(name);
        }

        function logicalCanvasToImage(n) {  // for mouse tracking
            return n * dpr / scale;
        }
        function imageToLogicalCanvas(n) {  // for image sizing
            return scale * n / dpr;
        }
        function imageToPhysicalCanvas(n) {  // for selection drawing
            return n * scale;
        }
        function logicalCanvastoPhysicalCanvas(n) {  // primarily for line strength scaling
            return n * dpr;
        }

        function setupCanvas(elem) {

            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels (larger on retina devices)
            let w = elem.offsetWidth;
            let h = elem.offsetHeight;
            elem.style.width = w + "px";
            elem.style.height = h + "px";

            let W = w * dpr;
            let H = h * dpr;
            elem.setAttribute("width", W);
            elem.setAttribute("height", H);

            return {
                elem: elem,
                ctx: elem.getContext("2d"),
                w: w,
                h: h,
                W: W,
                H: H
            }
        }

        //////////////////
        // CANVAS SETUP //
        //////////////////

        function setupPrecisionHelper() {
            let prec = document.getElementById("prec");
            precisionHelper = setupCanvas(prec);
            renderPrecisionHelper();
        }

        function setupWork() {
            work = document.getElementById("work");
            setupCanvas(work);
        }


        ///////////////////////
        // IMAGE (RE)LOADING //
        ///////////////////////

        document.querySelector('.dropper').addEventListener('dragover', e => {
            e.preventDefault();
            document.querySelector('.dropper').classList.add("active");
        });
        document.querySelector('.dropper').addEventListener('dragleave', e => {
            e.preventDefault();
            document.querySelector('.dropper').classList.remove("active");
        });
        document.querySelector('.dropper').addEventListener('drop', e => {
            dropImage(e);
            document.querySelector('.dropper').classList.remove("active");
        });
        document.querySelector('.drop-or-select').addEventListener('click', e => {
            e.preventDefault();
            document.getElementById("upload-image").click();
        });
        document.getElementById("upload-image").addEventListener('change', pickImage);

        document.querySelector('.another-image-dropper').addEventListener('dragover', e => {
            e.preventDefault();
            document.querySelector('.another-image-dropper').classList.add("active");
        });
        document.querySelector('.another-image-dropper').addEventListener('dragleave', e => {
            e.preventDefault();
            document.querySelector('.another-image-dropper').classList.remove("active");
        });
        document.querySelector('.another-image-dropper').addEventListener('drop', e => {
            dropImage(e);
            document.querySelector('.another-image-dropper').classList.remove("active");
        });
        document.querySelector('.another-image-dropper').addEventListener('click', e => {
            e.preventDefault();
            console.log(e);
            document.getElementById("upload-another-image").click();
        });
        document.getElementById("upload-another-image").addEventListener('change', pickImage);

        function dropImage(e) {
            e.preventDefault();
            setStatus("Setting up image…", true);

            let files = e.dataTransfer.files;
            console.log(files);
            if (files.length == 1) {

                // TODO deduplicate this with button-press-way of adding a file
                let file = files[0];

                if (!file.type.includes("image")) {
                    showError("It seems like \"" + file.name + "\" isn't an image, so I don't know what to do with it. Please drop an image instead.");
                    clearStatus();
                    return;
                }

                processDroppedOrPickedImage(file);
            } else {
                clearStatus();
                showError("It seems like you've dropped " + files.length + " files. Please drop only one.");
            }
        }

        function pickImage(e) {
            setStatus("Setting up image…", true);

            let files = e.target.files;

            // the missing "multiple" html attribute prevents more than one file from bein uploaded, and the "accept" attribute makes sure only images can be selected, so we don't need to handle the same errors as for dropping
            let file = files[0];
            processDroppedOrPickedImage(file);

            e.target.value = "";
        }

        function processDroppedOrPickedImage(file) {
            imageInfo.name = file.name;
            imageInfo.size = file.size;

            let reader = new FileReader();
            reader.onload = e => {
                installImage(e.target.result);
                clearStatus();  // TODO eh
            };
            reader.readAsDataURL(file);
        }

        document.querySelector('.load-sample').addEventListener('click', e => {
            e.preventDefault();
            setStatus("Setting up sample image…", true);
            let filename = "sample-sw42.286577541476696,-113.90409924217032ne42.340476458523305,-113.80691475782969.jpg";

            imageInfo.name = filename;
            imageInfo.size = 7383532;

            installImage(filename);
            clearStatus();
        });

        function installImage(src) {

            // store the image in a hidden img tag
            document.getElementById("dropped-image").addEventListener('load', e => {
                document.querySelector(".dropper").setAttribute("style", "display: none;");
                scale = null;
                drawNewImage();
                geoRect = null;
                extractAndSetGeoRect(imageInfo.name);
                currentlySelectingCircle = false;
                currentCircle = null;
                highlightedCircleId = null;
                circles = [];
                relevantGeoSelections = [];
                clearTable();
                recoverSelectionsFromSelectionCache();
                extractRelevantGeoSelectionsFromSelectionCache();
                renderWork();
            });
            document.getElementById("dropped-image").setAttribute("src", src);
        }

        function drawNewImage() {
            let image = document.getElementById("dropped-image");

            imageInfo.width = image.width;
            imageInfo.height = image.height;
            imageInfo.fileid = btoa(imageInfo.name + imageInfo.size + imageInfo.width + imageInfo.height);

            let scaleX = work.width / image.width;
            let scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);

            document.getElementById("base-image").setAttribute("src", image.src);
            document.getElementById("base-image").setAttribute("width", imageToLogicalCanvas(image.width))
            document.getElementById("base-image").setAttribute("height", imageToLogicalCanvas(image.height));

            renderWork();
        }

        ///////////////////
        // GEO-AWARENESS //
        ///////////////////

        // TODO move this section to a better location?

        function extractAndSetGeoRect(filename) {

            // shoutout to https://regexr.com
            let regex = /sw(-?\d+.\d+),(-?\d+.\d+)ne(-?\d+.\d+),(-?\d+.\d+)/;
            let match = filename.match(regex);
            if (match && match.length == 5) {
                geoRect = {
                    sw: {
                        lat: parseFloat(match[1]),
                        lon: parseFloat(match[2])
                    },
                    ne: {
                        lat: parseFloat(match[3]),
                        lon: parseFloat(match[4])
                    }
                };
            }
        }

        // TODO note: x, y in image space
        // TODO note: actually correct, even for large areas, taken from aerialbot
        // TODO split into toLat and toLon?
        function getLatLon(x, y) {
            let image = document.getElementById("dropped-image");

            // invert y (since image y increases from top to bottom, but latitude increases from bottom to top)
            y = image.height - y;

            // relativize
            x /= image.width;
            y /= image.height;

            let radians = x => x * Math.PI / 180;
            let degrees = x => x * 180 / Math.PI;

            // this disregards the possiblity of the geoRect running through the +-180° lon line, but that's not gonna happen in actual use
            let west = geoRect.sw.lon;
            let east = geoRect.ne.lon;
            let width = east - west;
            let lon = west + width * x;

            let north = radians(geoRect.ne.lat);
            let south = radians(geoRect.sw.lat);
            let lat = degrees(Math.asin(y * (Math.sin(north) - Math.sin(south)) + Math.sin(south)));

            return {lat: lat, lon: lon};
        }

        function getXY(lat, lon) {
            let image = document.getElementById("dropped-image");

            let radians = x => x * Math.PI / 180;
            let degrees = x => x * 180 / Math.PI;

            let west = geoRect.sw.lon;
            let east = geoRect.ne.lon;
            let width = east - west;
            let x = (lon - west) / width;

            let north = radians(geoRect.ne.lat);
            let south = radians(geoRect.sw.lat);
            let y = (Math.sin(radians(lat)) - Math.sin(south)) / (Math.sin(north) - Math.sin(south));

            x *= image.width;
            y *= image.height;

            y = image.height - y;

            return {x: x, y: y};
        }

        // TODO refine this. share radians function, remove (also in other places) dependency on .dropped-image (store image size in js)
        function getMetersPerPixel(lat) {
            let image = document.getElementById("dropped-image");
            let earthCircumference = 40075.016686 * 1000;  // in meters, at the equator
            let radians = x => x * Math.PI / 180;
            metersPerPixel = ((earthCircumference / image.width) * Math.cos(radians(lat))) / (360 / (geoRect.ne.lon - geoRect.sw.lon));
            return metersPerPixel;
        }

        // TODO: this is the length of n (image space pixels) in meters at lat,lon
        function getMeters(lat, px) {
            return getMetersPerPixel(lat) * px;
        }

        // n in meters
        function getPixels(lat, m) {
            return m / getMetersPerPixel(lat);
        }

        ////////////////////
        // CANVAS DRAWING //
        ////////////////////

        function renderPrecisionHelper() {
            let pc = precisionHelper.ctx;
            let W = precisionHelper.W;
            let H = precisionHelper.H;
            let w = precisionHelper.w;
            let h = precisionHelper.h;

            pc.clearRect(0, 0, W, H);

            pc.lineWidth = logicalCanvastoPhysicalCanvas(1);
            pc.strokeStyle = readCssVar("current-selection-stroke");

            if (currentCircle) {
                let image = document.getElementById("dropped-image");
                let x = currentCircle.x;
                let y = currentCircle.y;
                let r = currentCircle.r;

                // TODO make this prettier, maybe it's possible to do all 9 cases in a general function like this?
                function drawImageSquare(xx, yy) {  // x, y from -1, 0, 1
                    let zoom = 1 / settings.precisionHelperZoom;
                    let rad = (xx != 0 && yy != 0) ? (r / Math.sqrt(2)) : r;  // corners
                    pc.drawImage(
                        image,
                        x + (xx * rad) - w/6 * zoom,
                        y + (yy * rad) - h/6 * zoom,
                        w/3 * zoom,
                        h/3 * zoom,
                        (1 + xx) * W/3,
                        (1 + yy) * H/3,
                        W/3,
                        H/3
                        );
                }

                let selectionRadius = r * dpr * settings.precisionHelperZoom;

                // center
                drawImageSquare(0, 0);
                pc.beginPath();
                pc.moveTo(W/2-W/18, H/2-H/18);
                pc.lineTo(W/2-W/72, H/2-H/72);
                pc.moveTo(W/2+W/72, H/2+H/72);
                pc.lineTo(W/2+W/18, H/2+H/18);
                pc.moveTo(W/2+W/18, H/2-H/18);
                pc.lineTo(W/2+W/72, H/2-H/72);
                pc.moveTo(W/2-W/72, H/2+H/72);
                pc.lineTo(W/2-W/18, H/2+H/18);
                pc.rect(W/2, H/2, 0.5 * dpr, 0.5 * dpr);
                pc.stroke();

                // top
                drawImageSquare(0, -1);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, H/6 + selectionRadius, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom
                drawImageSquare(0, 1);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, 5*H/6 - selectionRadius, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // left
                drawImageSquare(-1, 0);
                pc.save();
                pc.beginPath();
                pc.rect(0, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius, H/2, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // right
                drawImageSquare(1, 0);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius, H/2, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top left
                drawImageSquare(-1, -1);
                pc.save();
                pc.beginPath();
                pc.rect(0, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius / Math.sqrt(2), H/6 + selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top right
                drawImageSquare(1, -1);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius / Math.sqrt(2), H/6 + selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom left
                drawImageSquare(-1, 1);
                pc.save();
                pc.beginPath();
                pc.rect(0, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius / Math.sqrt(2), 5*H/6 - selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom right
                drawImageSquare(1, 1);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius / Math.sqrt(2), 5*H/6 - selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();
            }

            pc.beginPath();
            pc.moveTo(W/3, 0);
            pc.lineTo(W/3, H);
            pc.moveTo(2*W/3, 0);
            pc.lineTo(2*W/3, H);
            pc.moveTo(0, H/3);
            pc.lineTo(W, H/3);
            pc.moveTo(0, 2*H/3);
            pc.lineTo(W, 2*H/3);
            pc.lineWidth = logicalCanvastoPhysicalCanvas(2);
            pc.strokeStyle = readCssVar("precision-helper-dividers-stroke");
            pc.stroke();
        }

        function renderWork() {
            let wc = work.getContext("2d");

            wc.clearRect(0, 0, work.width, work.height);
            wc.lineWidth = logicalCanvastoPhysicalCanvas(1);

            if (currentCircle) {
                wc.strokeStyle = readCssVar("current-selection-stroke");

                wc.beginPath();
                wc.setLineDash([logicalCanvastoPhysicalCanvas(6), logicalCanvastoPhysicalCanvas(4)]);
                wc.arc(imageToPhysicalCanvas(currentCircle.x), imageToPhysicalCanvas(currentCircle.y), imageToPhysicalCanvas(currentCircle.r), 0, 2 * Math.PI);
                wc.moveTo(imageToPhysicalCanvas(currentCircle.x), imageToPhysicalCanvas(currentCircle.y));
                wc.lineTo(imageToPhysicalCanvas(currentCircle.px), imageToPhysicalCanvas(currentCircle.py));
                wc.stroke();
                wc.setLineDash([]);

                if (!settings.transparentBackground) {
                    wc.beginPath();
                    wc.setLineDash([logicalCanvastoPhysicalCanvas(2), logicalCanvastoPhysicalCanvas(4)]);
                    wc.rect(
                        imageToPhysicalCanvas(currentCircle.x - (settings.horizontalMargin + 1) * currentCircle.r),
                        imageToPhysicalCanvas(currentCircle.y - (settings.verticalMargin + 1) * currentCircle.r),
                        imageToPhysicalCanvas((2 * settings.horizontalMargin + 2) * currentCircle.r),
                        imageToPhysicalCanvas((2 * settings.verticalMargin + 2) * currentCircle.r)
                        );
                    wc.stroke();
                    wc.setLineDash([]);
                }
            }

            if (settings.showOldSelections) {
                wc.strokeStyle = readCssVar("old-selections-stroke");
                wc.fillStyle = readCssVar("old-selections-fill");
                circles.forEach(circle => {

                    // don't yet draw the highlighted one
                    if (circle.id != highlightedCircleId) {
                        wc.beginPath();
                        wc.arc(imageToPhysicalCanvas(circle.x), imageToPhysicalCanvas(circle.y), imageToPhysicalCanvas(circle.r), 0, 2 * Math.PI);
                        wc.fill();
                        wc.stroke();
                    }
                });
            }

            // show geo-relevant circles from other images
            wc.strokeStyle = readCssVar("old-selections-stroke");
            wc.fillStyle = "transparent";
            wc.setLineDash([logicalCanvastoPhysicalCanvas(3), logicalCanvastoPhysicalCanvas(6)]);
            relevantGeoSelections.forEach(circle => {
                if (circle.id != highlightedCircleId) {
                    wc.beginPath();
                    wc.arc(imageToPhysicalCanvas(circle.x), imageToPhysicalCanvas(circle.y), imageToPhysicalCanvas(circle.r), 0, 2 * Math.PI);
                    wc.fill();
                    wc.stroke();
                }
            });
            wc.setLineDash([]);

            if (highlightedCircleId) {
                let circle = getCircle(highlightedCircleId)
                if (!circle) {
                    circle = getRelevantGeoSelection(highlightedCircleId);
                }

                // TODO note: it's possible for there to not be a circle for the passed id iff the user has just deleted a circle through the table in the sidebar – before the table row disappears, the mouseover event is fired at least one more time, calling this function
                if (circle) {
                    wc.strokeStyle = readCssVar("highlighted-selection-stroke");
                    wc.fillStyle = readCssVar("highlighted-selection-fill");

                    wc.beginPath();
                    wc.arc(imageToPhysicalCanvas(circle.x), imageToPhysicalCanvas(circle.y), imageToPhysicalCanvas(circle.r), 0, 2 * Math.PI);
                    wc.fill();
                    wc.stroke();

                    // TODO deduplicate with code above
                    if (!settings.transparentBackground) {
                        wc.beginPath();
                        wc.setLineDash([logicalCanvastoPhysicalCanvas(2), logicalCanvastoPhysicalCanvas(3)]);
                        wc.rect(
                            imageToPhysicalCanvas(circle.x - (settings.horizontalMargin + 1) * circle.r),
                            imageToPhysicalCanvas(circle.y - (settings.verticalMargin + 1) * circle.r),
                            imageToPhysicalCanvas((2 * settings.horizontalMargin + 2) * circle.r),
                            imageToPhysicalCanvas((2 * settings.verticalMargin + 2) * circle.r)
                            );
                        wc.stroke();
                        wc.setLineDash([]);
                    }
                }
            }
        }


        //////////////////////
        // CIRCLE SELECTION //
        //////////////////////

        document.getElementById("work").addEventListener('mousedown', event => {

            // only react if a normal click was performed
            if (event.button != 0) {
                return;
            }

            currentlySelectingCircle = true;
            currentCircle = {
                x: logicalCanvasToImage(event.pageX),  // - left offset of #work wrt viewport if top left corner of canvas were not at (0,0)
                y: logicalCanvasToImage(event.pageY),  // analogous
                px: logicalCanvasToImage(event.pageX),
                py: logicalCanvasToImage(event.pageY),
                r: 0
            };
            renderWork();
            renderPrecisionHelper();
        });
        document.getElementById("work").addEventListener('mousemove', event => {
            if (currentlySelectingCircle) {
                let px = logicalCanvasToImage(event.pageX);  // see caveat above
                let py = logicalCanvasToImage(event.pageY);  // analogous

                let dx = Math.abs(px - currentCircle.x);
                let dy = Math.abs(py - currentCircle.y);
                let r = Math.sqrt(dx ** 2 + dy ** 2);

                currentCircle.px = px;
                currentCircle.py = py;
                currentCircle.r = r;
                renderWork();
                renderPrecisionHelper();
            }
        });
        document.getElementById("work").addEventListener('mouseup', event => {
            currentlySelectingCircle = false;

            // on click, copy previous selection. currentCircle.r is always set here since it's been initialized in the mousedown event
            if (currentCircle.r == 0 && circles.length > 0) {
                let x = logicalCanvasToImage(event.pageX);  // see caveat above
                let y = logicalCanvasToImage(event.pageY);  // analogous

                cloneMostRecentSelectionAt(x, y);
            }
            renderWork();
            renderPrecisionHelper();
        });

        // TODO okay, so this is sort of a generic function for checking which circle is closest to the pointer.
        document.getElementById("work").addEventListener('click', event => {
            let x = logicalCanvasToImage(event.pageX);
            let y = logicalCanvasToImage(event.pageY);
            let candidateGeoSelections = relevantGeoSelections.filter(circle => {

                // TODO dedup, make euclid dist function
                let dx = Math.abs(x - circle.x);
                let dy = Math.abs(y - circle.y);
                return circle.r > Math.sqrt(dx ** 2 + dy ** 2);
            });
            if (candidateGeoSelections.length > 0) {
                event.preventDefault();
                let id = -1;
                let mindist = 999999999;
                candidateGeoSelections.forEach(circle => {
                    let dx = Math.abs(x - circle.x);
                    let dy = Math.abs(y - circle.y);
                    if (Math.sqrt(dx ** 2 + dy ** 2) < mindist) {
                        mindist = Math.sqrt(dx ** 2 + dy ** 2);
                        id = circle.id;
                    }
                });
                console.log(candidateGeoSelections.find(c => c.id == id));
            }
        });

        // TODO move this function to a better place
        function cloneMostRecentSelectionAt(x, y) {
            let previousCircle = circles[circles.length-1];
            currentCircle = {
                x: x,
                y: y,
                px: (previousCircle.px - previousCircle.x) + x,
                py: (previousCircle.py - previousCircle.y) + y,
                r: previousCircle.r
            };
        }


        ///////////////////
        // CIRCLES TABLE //
        ///////////////////

        function getCircle(id) {
            return circles.find(c => c.id == id);
        }

        function addToTable(id) {
            document.querySelector(".circles-table-container").classList.remove("hidden");

            let table = document.getElementById("circles-table-body");
            let circle = getCircle(id);

            let lat = "";
            let lon = "";
            let rm = "";
            if (circle.geo) {
                lat = `<span>${(circle.lat + "").toString().substring(0,8)}°</span>`;
                lon = `<span>${(circle.lon + "").substring(0,8)}°</span>`;
                rm = `<span>${parseInt(circle.rm)}m</span>`;
            }

            let cells = `
                <td>${parseInt(circle.x)}<u>px</u> ${lon}</td>
                <td>${parseInt(circle.y)}<u>px</u> ${lat}</td>
                <td>${parseInt(circle.r)}<u>px</u> ${rm}</td>
                <td>
                    <button onclick="cropAndDownload(${id})">
                        <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                    </button>
                    <button onclick="deleteCircle(${id})" class="delete">
                        <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M-9,-9 L9,9 M-9,9 L9,-9"></path></svg>
                    </button>
                </td>
                `;

            let tr = document.createElement("tr");
            tr.id = id;
            tr.setAttribute("onmouseover", "highlightCircle(" + id + ")");  // would register this with js, but that's almost less elegant than this
            tr.setAttribute("onmouseout", "highlightCircle(null)");
            tr.innerHTML = cells;

            table.insertBefore(tr, table.firstChild);
        }

        function clearTable() {
            let table = document.getElementById("circles-table-body");
            table.innerHTML = "";
        }

        function renderRelevantGeoSelectionsTable() {
            if (relevantGeoSelections.length > 0) {
                document.querySelector(".circles-table-container").classList.remove("hidden");
            }

            let table = document.getElementById("circles-table-foot");
            table.innerHTML = "";

            relevantGeoSelections.forEach(circle => {
                let lat = `<span>${(circle.lat + "").toString().substring(0,8)}°</span>`;
                let lon = `<span>${(circle.lon + "").substring(0,8)}°</span>`;
                let rm = `<span>${parseInt(circle.rm)}m</span>`;

                let cells = `
                    <td>${lon}</td>
                    <td>${lat}</td>
                    <td>${rm}</td>
                    <td>
                        <button onclick="acceptGeoSelection(${circle.id})">
                            <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M-10,1 L0,9 L9,-9"></path></svg>
                        </button>
                    </td>
                    `;

                let tr = document.createElement("tr");
                tr.id = circle.id;
                tr.setAttribute("onmouseover", "highlightCircle(" + circle.id + ")");  // would register this with js, but that's almost less elegant than this
                tr.setAttribute("onmouseout", "highlightCircle(null)");
                tr.innerHTML = cells;

                table.insertBefore(tr, table.firstChild);
            });
        }

        function acceptGeoSelection(id) {
            let circle = getRelevantGeoSelection(id);

            circle.geoid = circle.id;
            circle.id = Date.now();
            circle.fileid = imageInfo.fileid;

            circles.push(circle);
            addToTable(circle.id);
            addToSelectionCache(circle);
            extractRelevantGeoSelectionsFromSelectionCache();

            renderWork();
        }

        function highlightCircle(id) {
            highlightedCircleId = id;
            renderWork();
        }

        function deleteCircle(id) {
            circles = circles.filter(c => c.id != id);
            removeFromSelectionCache(id);
            document.getElementById(id).remove();
            extractRelevantGeoSelectionsFromSelectionCache();
            renderWork();
        }

        function deleteAllCircles() {
            circles.forEach(c => {
                removeFromSelectionCache(c.id);
                document.getElementById(c.id).remove();
            });
            circles = [];
            extractRelevantGeoSelectionsFromSelectionCache();
            renderWork();

            setStatus("Successfully deleted all current selections.")
        }


        /////////////////////////
        // CROPPING & DOWNLOAD //
        /////////////////////////

        function assembleFilename(id) {
            let circle = getCircle(id);

            // super basic string variable replacement, via https://stackoverflow.com/a/1408373
            let supplant = (s, o) => {
                return s.replace(/{([^{}]*)}/g,
                    function (a, b) {
                        var r = o[b];
                        return typeof r === 'string' || typeof r === 'number' ? r : a;
                    }
                );
            };

            // TODO more? original filename, date, ...
            let filenameVariables = {
                x: parseInt(circle.x),
                y: parseInt(circle.y),
                r: parseInt(circle.r)
            }

            if (circle.geo) {
                filenameVariables = Object.assign(filenameVariables, {
                    lat: circle.lat,
                    lon: circle.lon,
                    rm: circle.rm
                });
            }

            let filename = supplant(settings.filenameTemplate, filenameVariables);

            if (filename == "") {  // this means the template was not set
                let defaultFilenameTemplate = "cropcircles-x{x}y{y}r{r}"
                if (geoRect) {
                    defaultFilenameTemplate += "-{lat},{lon},{rm}m"
                }
                filename = supplant(defaultFilenameTemplate, filenameVariables);
            }

            return filename;
        }

        function cropImageToSelection(id) {
            let circle = getCircle(id);

            let x = circle.x;
            let y = circle.y;
            let r = circle.r;

            let width = Math.ceil(r * 2);
            let height = Math.ceil(r * 2);
            if (!settings.transparentBackground) {
                width += 2 * r * settings.horizontalMargin;
                height += 2 * r * settings.verticalMargin;
            }

            let image = document.getElementById("dropped-image");
            let croppedImage = document.getElementById("cropped-image");

            croppedImage.setAttribute("width", width);
            croppedImage.setAttribute("height", height);

            let cic = croppedImage.getContext("2d");
            cic.clearRect(0, 0, width, height);

            if (!settings.transparentBackground) {
                cic.drawImage(image, x - r - r * settings.horizontalMargin, y - r - r * settings.verticalMargin, width, height, 0, 0, width, height);
            }
            else {
                cic.save();
                cic.beginPath();
                cic.arc(r, r, r, 0, 2 * Math.PI);
                cic.closePath();
                cic.clip();
                cic.drawImage(image, x - r, y - r, width, height, 0, 0, width, height);
                cic.restore();
            }

            return croppedImage;
        }

        function cropAndBlob(id, blobAction) {
            let croppedImage = cropImageToSelection(id);
            let filename = assembleFilename(id);

            let imageType = "image/png";
            let imageQuality = 1;
            let imageExtension = ".png";
            if (!settings.transparentBackground) {
                imageType = "image/jpeg";
                imageExtension = ".jpg";
            }

            croppedImage.toBlob(blob => {
                blobAction(filename + imageExtension, blob);
            }, imageType, imageQuality);
        }

        function cropAndDownload(id) {
            cropAndBlob(id, (filename, blob) => {
                let url = URL.createObjectURL(blob);
                let dummyLink = document.createElement("a");
                dummyLink.setAttribute("href", url);
                dummyLink.setAttribute("download", filename);
                dummyLink.style.display = "none";
                document.body.appendChild(dummyLink);
                dummyLink.click();
                document.body.removeChild(dummyLink);

                URL.revokeObjectURL(url);
            });
        }

        async function cropAndDownloadAll() {

            // pieced together from jszip docs and fiddling around, genuinely no clue how it works or if it could be done better
            let filename = "cropcircles-" + imageInfo.name.replace(/\./g, "-") + ".zip";
            setStatus("Generating ZIP – this might take a bit as there's " + circles.length + " crops to be performed…", true);

            let zip = new JSZip();

            let promises = circles.map(circle => {
                return new Promise(function (resolve, reject) {
                    cropAndBlob(circle.id, (filename, blob) => {
                        resolve([filename, blob]);
                    });
                });
            });

            let resolveds = await Promise.all(promises);
            resolveds.forEach(content => {
                zip.file(content[0], content[1]);
            });

            zip.generateAsync({type: "blob"})
                .then(function(blob) {
                    let url = URL.createObjectURL(blob);
                    let dummyLink = document.createElement("a");
                    dummyLink.setAttribute("href", url);
                    dummyLink.setAttribute("download", filename);
                    dummyLink.style.display = "none";
                    document.body.appendChild(dummyLink);
                    dummyLink.click();
                    document.body.removeChild(dummyLink);

                    URL.revokeObjectURL(url);

                    clearStatus();
                });
        }


        //////////////////////////
        // KEYBOARD INTERACTION //
        //////////////////////////

        function acceptCurrentCircle() {
            if (!currentCircle) {
                return;
            }

            // TODO move/change this status, only show if actuall cropping
            setStatus("Cropping image…", true);

            let circle = {
                id: Date.now(),
                fileid: imageInfo.fileid,
                x: currentCircle.x,
                y: currentCircle.y,
                px: currentCircle.px,
                py: currentCircle.py,
                r: currentCircle.r,
                geo: false
            };

            if (geoRect) {
                let latlon = getLatLon(currentCircle.x, currentCircle.y);
                let platlon = getLatLon(currentCircle.px, currentCircle.py);
                let rm = getMeters(latlon.lat, currentCircle.r);
                circle = Object.assign(circle, {
                    geo: true,
                    geoid: circle.id,
                    lat: latlon.lat,
                    lon: latlon.lon,
                    plat: platlon.lat,
                    plon: platlon.lon,
                    rm: rm
                });
            }

            circles.push(circle);
            currentCircle = null;

            addToTable(circle.id);
            addToSelectionCache(circle);
            if (settings.downloadImmediately) {
                cropAndDownload(circle.id);
            }

            renderWork();
            renderPrecisionHelper();

            clearStatus();
        }

        function cancelCurrentCircle() {
            currentCircle = null;
            renderWork();
            renderPrecisionHelper();
        }

        function scaleCurrentCircle(s) {
            currentCircle.r += s;
            if (currentCircle.r < 0) {
                currentCircle.r = 0;
            }

            // this took some figuring out!
            let f = currentCircle.r / (currentCircle.r - s);
            currentCircle.px = currentCircle.x + (currentCircle.px - currentCircle.x) * f;
            currentCircle.py = currentCircle.y + (currentCircle.py - currentCircle.y) * f;

            renderWork();
            renderPrecisionHelper();
        }

        // TODO do nothing if there is not current circle (to avoid console errors more than anything) – the same goes for related functions
        function moveCurrentCircle(x, y) {

            // TODO comment: selection cloning on move: move it by 2r
            if (!currentCircle && circles.length > 0) {
                let circle = circles[circles.length-1];
                let x0 = circle.x + Math.sign(x) * 2 * circle.r;
                let y0 = circle.y + Math.sign(y) * 2 * circle.r;
                cloneMostRecentSelectionAt(x0, y0);
            }

            currentCircle.x += x;
            currentCircle.y += y;
            currentCircle.px += x;
            currentCircle.py += y;

            renderWork();
            renderPrecisionHelper();
        }

        // TODO only enable this once image has been dropped and a selection has been made?
        window.addEventListener("keydown", function (event) {

            // disable this if the focus is on one of the inputs in the sidebar – interferes with filename input, possibly others too!
            // or if any modifiers are pressed – the user is trying to interact with their browser, not with me!
            if (event.target.tagName == "INPUT" || event.ctrlKey || event.altKey || event.metaKey) {
                return;
            }

            let factor = 1;
            let larger = 20;
            if (event.shiftKey) {
                factor = larger;
            }

            switch (event.key) {
                case "Enter":
                    acceptCurrentCircle();
                    break;
                case "Escape":
                    cancelCurrentCircle();
                    break;

                case "ArrowUp":
                case "w":
                case "W":
                    moveCurrentCircle(0, -factor);
                    break;
                case "ArrowDown":
                case "s":
                case "S":
                    moveCurrentCircle(0, factor);
                    break;
                case "ArrowLeft":
                case "a":
                case "A":
                    moveCurrentCircle(-factor, 0);
                    break;
                case "ArrowRight":
                case "d":
                case "D":
                    moveCurrentCircle(factor, 0);
                    break;

                case "+":
                case "p":
                case "P":
                    scaleCurrentCircle(factor);
                    break;
                case "*":  // "shift +" on the German keyboard layout i use
                    scaleCurrentCircle(larger);
                    break;
                case "-":
                case "o":
                case "O":
                    scaleCurrentCircle(-factor);
                    break;
                case "_":  // "shift -" on the German keyboard layout i use
                    scaleCurrentCircle(-larger);
                    break;

                default:
                  return;  // quit when we don't want to handle the key event
              }

              // TODO switch based on .code ("KeyW", etc.) for wasd. how to handle default case above then?

            // cancel the default action to avoid it being handled twice
            event.preventDefault();
        }, true);


        /////////////////////
        // WINDOW RESIZING //
        /////////////////////

        // TODO future changes to setupWork and drawNewImage might break this. safeguard agains this through abstraction or documentation!
        window.addEventListener('resize', () => {
            let h = window.innerHeight
            let w = window.innerWidth - document.querySelector(".sidebar").offsetWidth;

            let workElem = document.getElementById("work");

            workElem.style.width = w + "px";
            workElem.style.height = h + "px";
            setupWork();

            drawNewImage();  // this sets scale

            renderWork();
        });


        //////////////
        // SETTINGS //
        //////////////

        let settings = {
            showOldSelections: null,
            precisionHelperZoom: null,
            downloadImmediately: null,
            filenameTemplate: null,
            transparentBackground: null,
            verticalMargin: null,
            horizontalMargin: null
        }

        let showOldSelectionsCheckbox = document.querySelector(".show-old-selections-checkbox");
        let precisionHelperZoomSlider = document.querySelector(".precision-helper-zoom-slider");
        let downloadImmediatelyCheckbox = document.querySelector(".download-immediately-checkbox");
        let filenameTemplateField = document.querySelector(".filename-template-field");

        let transparentBackgroundCheckbox = document.querySelector(".transparent-background-checkbox");
        let marginSettings = document.querySelector(".margin-settings");
        let verticalMarginSlider = document.querySelector(".vertical-margin-slider");
        let horizontalMarginSlider = document.querySelector(".horizontal-margin-slider");

        function initSettingsFromLocalStorage() {
            let s = window.localStorage.getItem("cropcircles-settings");
            try {
                if (s == null) {
                    throw '';
                }
                settings = JSON.parse(s);
            } catch (e) {
                resetSettingsToDefaults();
            }
        }

        function writeSettingsToLocalStorage() {
            window.localStorage.setItem("cropcircles-settings", JSON.stringify(settings));
        }

        function downloadSettings() {
            let url = "data:application/json;charset=utf-8," + encodeURIComponent(JSON.stringify({settings: settings}));
            let dummyLink = document.createElement("a");
            dummyLink.setAttribute("href", url);
            dummyLink.setAttribute("download", "cropcircles-settings.json");
            dummyLink.style.display = "none";
            document.body.appendChild(dummyLink);
            dummyLink.click();
            document.body.removeChild(dummyLink);
        }

        function restoreSettings() {
            document.getElementById("upload-settings").click();
        }

        document.getElementById("upload-settings").addEventListener('change', e => {
            let files = document.getElementById("upload-settings").files;
            let file = files[0];

            let filename = file.name;

            let reader = new FileReader();
            reader.onload = e => {
                try {
                    let s = e.target.result;

                    let rawSettings;
                    try {
                        rawSettings = JSON.parse(s);
                    } catch (e) {
                        showError("The file \"" + file.name + "\" doesn't seem to contain a valid JSON value.");
                    }

                    if (!("settings" in rawSettings)) {
                        showError("The file \"" + file.name + "\" doesn't contain a \"settings\" attribute. Did you upload a selection cache backup by accident?");
                        return;
                    }
                    settings = rawSettings.settings;
                    applySettingsView();
                    setStatus("Successfully restored settings from \"" + filename + "\".")

                    // forget about the file, allowing the event handler to fire again if the user uploads the same file again
                    document.getElementById("upload-settings").value = "";
                } catch (e) {
                    showError("The file \"" + file.name + "\" doesn't seem to contain a valid JSON value.");
                }
            };
            reader.readAsText(file);
        });

        function applySettingsView() {

            // adjust dom to match settings
            showOldSelectionsCheckbox.checked = settings.showOldSelections;
            updateShowOldSelections(showOldSelectionsCheckbox);

            precisionHelperZoomSlider.value = settings.precisionHelperZoom;
            adjustPrecisionHelperZoom(precisionHelperZoomSlider);

            downloadImmediatelyCheckbox.checked = settings.downloadImmediately;
            updateDownloadImmediately(downloadImmediatelyCheckbox);

            filenameTemplateField.value = settings.filenameTemplate;
            updateFilenameTemplate(filenameTemplateField);

            transparentBackgroundCheckbox.checked = settings.transparentBackground;
            updateTransparentBackground(transparentBackgroundCheckbox);

            verticalMarginSlider.value = settings.verticalMargin;
            adjustVerticalMargin(verticalMarginSlider);

            horizontalMarginSlider.value = settings.horizontalMargin;
            adjustHorizontalMargin(horizontalMarginSlider);
        }

        function setupSettings() {
            initSettingsFromLocalStorage();
            applySettingsView();
        }

        function resetSettingsToDefaults() {
            showOldSelectionsCheckbox.checked = showOldSelectionsCheckbox.getAttribute("data-default") == "yes";
            updateShowOldSelections(showOldSelectionsCheckbox);
            precisionHelperZoomSlider.value = precisionHelperZoomSlider.getAttribute("data-default");
            adjustPrecisionHelperZoom(precisionHelperZoomSlider);
            downloadImmediatelyCheckbox.checked = downloadImmediatelyCheckbox.getAttribute("data-default") == "yes";
            updateDownloadImmediately(downloadImmediatelyCheckbox);
            filenameTemplateField.value = filenameTemplateField.getAttribute("data-default");
            updateFilenameTemplate(filenameTemplateField);

            transparentBackgroundCheckbox.checked = transparentBackgroundCheckbox.getAttribute("data-default") == "yes";
            updateTransparentBackground(transparentBackgroundCheckbox);
            verticalMarginSlider.value = verticalMarginSlider.getAttribute("data-default");
            adjustVerticalMargin(verticalMarginSlider);
            horizontalMarginSlider.value = horizontalMarginSlider.getAttribute("data-default");
            adjustHorizontalMargin(horizontalMarginSlider);

            setStatus("Successfully reset the settings to their default values.")
        }

        function updateShowOldSelections(checkbox) {
            settings.showOldSelections = !!checkbox.checked;
            writeSettingsToLocalStorage();
            renderWork();
        }

        function adjustPrecisionHelperZoom(slider) {
            settings.precisionHelperZoom = parseFloat(slider.value);
            precisionHelperZoomSlider.parentNode.querySelector("b").innerHTML = settings.precisionHelperZoom + "×";
            writeSettingsToLocalStorage();
            renderPrecisionHelper();
        }

        function updateDownloadImmediately(checkbox) {
            settings.downloadImmediately = !!checkbox.checked;
            writeSettingsToLocalStorage();
        }

        function updateFilenameTemplate(field) {
            settings.filenameTemplate = field.value;
            writeSettingsToLocalStorage();
        }

        function updateTransparentBackground(checkbox) {
            settings.transparentBackground = !!checkbox.checked;
            writeSettingsToLocalStorage();
            if (settings.transparentBackground) {
                marginSettings.classList.add("disabled");
                verticalMarginSlider.disabled = true;
                horizontalMarginSlider.disabled = true;
            } else {
                marginSettings.classList.remove("disabled");
                verticalMarginSlider.disabled = false;
                horizontalMarginSlider.disabled = false;
            }
            renderWork();
        }

        function computeAspectRatio() {
            let w = (2 * (settings.horizontalMargin + 1));
            let h = (2 * (settings.verticalMargin + 1));
            let aspectRatio = w / h;

            // some common values, could do this more nicely with a gcd algorithms, but meh
            if (aspectRatio == 16 / 9) {
                return "16:9";
            } else if (aspectRatio == 4 / 3) {
                return "4:3";
            } else if (aspectRatio == 3 / 2) {
                return "3:2";
            } else if (aspectRatio == 2 / 1) {
                return "2:1";
            }

            return (aspectRatio + "").substring(0, 4) + ":" + 1;
        }

        function adjustVerticalMargin(slider) {
            settings.verticalMargin = parseFloat(slider.value);
            verticalMarginSlider.parentNode.querySelector("b").innerHTML = settings.verticalMargin + "·<em>r</em>";
            document.querySelector(".aspect-ratio").innerText = computeAspectRatio();
            writeSettingsToLocalStorage();
            renderWork();
        }

        function adjustHorizontalMargin(slider) {
            settings.horizontalMargin = parseFloat(slider.value);
            horizontalMarginSlider.parentNode.querySelector("b").innerHTML = settings.horizontalMargin + "·<em>r</em>";
            document.querySelector(".aspect-ratio").innerText = computeAspectRatio();
            writeSettingsToLocalStorage();
            renderWork();
        }


        /////////////////////
        // SELECTION CACHE //
        /////////////////////

        function initSelectionCacheFromLocalStorage() {
            let s = window.localStorage.getItem("cropcircles-selectioncache");
            try {
                if (s == null) {
                    throw '';
                }
                selectionCache = JSON.parse(s);
            } catch (e) {
                purgeSelectionCache();
            }
        }

        function setupSelectionCache() {
            initSelectionCacheFromLocalStorage();
        }

        // TODO dedup this with the same for settings
        function downloadSelectionCache() {
            let url = "data:application/json;charset=utf-8," + encodeURIComponent(JSON.stringify({selectioncache: selectionCache}));
            let dummyLink = document.createElement("a");
            dummyLink.setAttribute("href", url);
            dummyLink.setAttribute("download", "cropcircles-selectioncache.json");
            dummyLink.style.display = "none";
            document.body.appendChild(dummyLink);
            dummyLink.click();
            document.body.removeChild(dummyLink);
        }

        // TODO dedup this with the same for settings
        function restoreSelectionCache() {
            document.getElementById("upload-selectioncache").click();
        }

        // TODO dedup this with the same for settings, by writing a function taking a callback that will be set as reader.onload (why not addeventlistener, btw?)
        document.getElementById("upload-selectioncache").addEventListener('change', e => {
            let files = document.getElementById("upload-selectioncache").files;   // TODO e.target? generally, standardize "event" or "e"
            let file = files[0];

            let filename = file.name;

            let reader = new FileReader();
            reader.onload = e => {
                let s = e.target.result;

                let rawSelectionCache;
                try {
                    rawSelectionCache = JSON.parse(s);
                } catch (e) {
                    showError("The file \"" + file.name + "\" doesn't seem to contain a valid JSON value.");
                }

                if (!("selectioncache" in rawSelectionCache)) {
                    showError("The file \"" + file.name + "\" doesn't contain a \"selectioncache\" attribute. Did you upload a settings backup by accident?");
                    return;
                }
                let tmpSelectionCache = rawSelectionCache.selectioncache;

                // merge with current selection cache: only add those that are not already in the selection cache
                tmpSelectionCache = tmpSelectionCache.filter(c => {
                    return null == selectionCache.find(cc => cc.id == c.id)
                });

                selectionCache = tmpSelectionCache;
                writeSelectionCacheToLocalStorage();
                extractRelevantSelectionsFromSelectionCache();

                setStatus("Successfully restored selection cache from \"" + filename + "\".");

                // forget about the file, allowing the event handler to fire again if the user uploads the same file again
                document.getElementById("upload-selectioncache").value = "";
            };
            reader.readAsText(file);
        });

        function recoverSelectionsFromSelectionCache() {
            let cachedCircles = selectionCache.filter(circle => {

                // if already in list of current selections (which can happen during restores or resets), no need to add it
                if (getCircle(circle.id)) {
                    return false;
                }

                // if from the same image, bullseye
                if (circle.fileid == imageInfo.fileid) {
                    return true;
                }

                return false;
            });
            cachedCircles.forEach(circle => {
                circles.push(circle);
                addToTable(circle.id);
            });

            renderWork();
        }

        function getRelevantGeoSelection(id) {
            return relevantGeoSelections.find(c => c.id == id);
        }

        function extractRelevantGeoSelectionsFromSelectionCache() {
            if (!geoRect) {
                return;
            }

            relevantGeoSelections = selectionCache.filter(circle => {

                // if already in list of current selections (which can happen during restores or resets) or from the same file, no need to add it
                if (getCircle(circle.geoid) || circles.find(c => c.geoid == circle.id) || circle.fileid == imageInfo.fileid) {
                    return false;
                }

                // if within the current georect, yeah!
                if (circle.geo && geoRect.sw.lat <= circle.lat && circle.lat <= geoRect.ne.lat && geoRect.sw.lon <= circle.lon && circle.lon <= geoRect.ne.lon) {
                    return true;
                }

                return false;
            });
            console.log(relevantGeoSelections);

            let i = 0;
            relevantGeoSelections = relevantGeoSelections.map(circle => {
                let xy = getXY(circle.lat, circle.lon);
                let pxy = getXY(circle.plat, circle.plon);
                let r = getPixels(circle.plat, circle.rm);

                // clone to avoid modifying the original, which "belongs" to another image
                circle = JSON.parse(JSON.stringify(circle));

                circle.x = xy.x;
                circle.y = xy.y;
                circle.px = pxy.x;
                circle.py = pxy.x;
                circle.r = r;

                return circle;
            });
            renderRelevantGeoSelectionsTable();
        }

        function addToSelectionCache(circle) {
            selectionCache.push(circle);
            writeSelectionCacheToLocalStorage();
        }

        function removeFromSelectionCache(id) {
            selectionCache = selectionCache.filter(c => c.id != id);
            writeSelectionCacheToLocalStorage();
        }

        function writeSelectionCacheToLocalStorage() {
            window.localStorage.setItem("cropcircles-selectioncache", JSON.stringify(selectionCache));
        }

        // reset to only include the current circles
        function purgeSelectionCache() {
            selectionCache = circles;
            writeSelectionCacheToLocalStorage();

            // hide any now-nonexistant geo selections
            extractRelevantGeoSelectionsFromSelectionCache();
            renderWork();

            setStatus("Successfully purged the selection cache – only your current selections remain.")
        }


        //////////////////
        // USER'S GUIDE //
        //////////////////

        // TODO build way of showing it if not already visible and scrolling to a specific section
        function showUsersGuide() {
            document.querySelector(".users-guide").setAttribute("style", "display: block;");
        }

        function hideUsersGuide() {
            document.querySelector(".users-guide").setAttribute("style", "display: none;");
        }


        /////////////////////
        // STATUS MESSAGES //
        /////////////////////

        // helper function for displaying status messages
        function setStatus(message, persist) {
            let status = document.querySelector(".status");
            status.innerHTML = message;
            status.classList.remove("hidden");
            if (!persist) {
                setTimeout(clearStatus, 2000);
            }
        }

        // helper function for hiding the current status message
        function clearStatus() {
            let status = document.querySelector(".status");
            status.classList.add("hidden");
        }


        ////////////////////
        // ERROR MESSAGES //
        ////////////////////

        function showError(message, label = true) {
            let error = document.querySelector(".error");
            error.classList.remove("hidden");
            let errorMessage = document.querySelector(".error-message");
            if (label) {
                message = "<strong>Error:</strong> " + message;
            }
            errorMessage.innerHTML = message;
        }

        function dismissError() {
            let error = document.querySelector(".error");
            error.classList.add("hidden");
        }


        //////////////////
        // MOBILE ALERT //
        //////////////////

        let mobileAlertAlreadyShown = false;

        // as per https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent and https://stackoverflow.com/a/24600597, throw an alert if the user agent contains "Mobi"
        if (/Mobi/.test(navigator.userAgent)) {
            showError(`Hi there! It looks like <em>you're using a mobile device</em>. Sadly, this app was built with mouse and keyboard interaction in mind – please move over to an old-fashioned computer and proceed there.`, false);
            mobileAlertAlreadyShown = true;
        }

        // also throw alert if the screen is touched
        document.addEventListener("touchstart", () => {
            if (!mobileAlertAlreadyShown) {
                showError(`Hi there! It looks like <em>you've just tapped the screen of your presumably-mobile device</em>. Sadly, this app was built with mouse and keyboard interaction in mind – please move over to an old-fashioned computer and proceed there.`, false);
                mobileAlertAlreadyShown = true;
            }
        });


        ////////////////////////////////////
        // IT'S LIGHTS OUT AND AWAY WE GO //
        ////////////////////////////////////

        if (window.devicePixelRatio) {
            dpr = window.devicePixelRatio;
        }

        setupPrecisionHelper();
        setupWork();

        setupSettings();
        setupSelectionCache();
    </script>
</body>
</html>
