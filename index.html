<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" lang="en">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <link rel="apple-touch-icon" href="assets/favicon.png">
    <title>Crop Circles</title>
    <link rel="stylesheet" href="assets/iosevka-aile/3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        :root {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", "Iosevka Aile", Iosevka, PragmataPro, monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --users-guide-background-color: #111;

            --status-background-color: #333;
            --error-background-color: #400;

            --precision-helper-background-color: #000;

            --main-background-color: #131313;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --danger-color: orangered;

            --dropper-background-color: #555;
            --dropper-color: #aaa;
            --another-image-dropper-background-color: #333;
            --another-image-dropper-color: #aaa;

            --current-selection-stroke: #fff;
            --selections-stroke: rgba(255,255,255,0.5);
            --selections-fill: rgba(255,255,255,0.2);
            --highlighted-selection-stroke: rgba(255,255,255,0.8);
            --highlighted-selection-fill: rgba(255,255,255,0.4);

            --selections-table-geodata-color: #aaa;

            --precision-helper-dividers-stroke: #555;
        }
        html {
            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem;
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        h1 svg {
            height: 0.75em;
            margin: 0 -0.05em 0 0.05em;
            transition: transform 2s ease-out;
        }
        h1 svg:hover {
            transition: transform 20s ease-in-out;
            transform: rotate(3600deg);
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        button, label, input[type="text"] {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem;
        }
        button:hover, label:hover, input[type="text"]:hover {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button {
            cursor: pointer;
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        input[type="checkbox"] {
            height: 1.25em;
            margin-right: 0.3em;
            vertical-align: text-bottom;  /* hack to make it look vertically centered in chrome but doesn't in firefox... hmm */
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"] {
            text-transform: none;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            float: right;
            font-weight: normal;
            text-transform: initial;
            color: var(--input-current-value-color);
        }
        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .backup-restore {
            display: flex;
        }
        .backup-restore button {
            margin: 0;
        }
        .backup-restore button:first-child {
            display: inline-block;
            width: 13em;
        }
        .backup-restore button:last-child {
            display: inline-block;
            width: 100%;
            margin-left: 0.5em;
        }
        .reset {
            text-transform: uppercase;
            font-size: 0.67em;
            letter-spacing: 0.1em;
        }
        .reset a {
            text-decoration: none;
        }
        .reset a:hover {
            background-color: var(--danger-color);
            color: var(--text-color);
        }
        .ceci-nest-pas-une-parametre,
        .ceci-nest-pas-une-parametre:hover {
            background-color: transparent;
        }

        /* ANOTHER IMAGE DROPPER */
        .another-image-dropper {
            margin: 1rem 0;
            border: 0.15rem dashed var(--another-image-dropper-color);
            border-radius: 0.7em;
            color: var(--another-image-dropper-color);
            background-color: var(--another-image-dropper-background-color);
            font-size: 1.4em;
            padding: 1rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
            cursor: pointer;
        }
        .another-image-dropper.active {
            background-color: inherit;
            filter: invert(1);
        }
        .another-image-dropper.hidden {
            display: none;
        }

        /* SELECTIONS TABLE */
        .selections-table-container.hidden {
            display: none;
        }
        .selections-table {
            width: calc(100% + 2em);
            margin-left: -1em;
            border-spacing: 0;
        }
        .selections-table thead {
            text-transform: uppercase;
            font-size: 0.9em;
            font-weight: 900;
        }
        .selections-table tr:hover,
        .selections-table tr.hover {
            background-color: var(--input-background-color);
        }
        .selections-table tfoot span {
            font-style: italic;
        }
        .selections-table td {
            padding: 0.25rem;
        }
        .selections-table td:first-child {
            padding-left: 1rem;
        }
        .selections-table td:last-child {
            text-align: right;
            padding-right: 1rem;
        }
        .selections-table #no-selections {
            display: none;
        }
        .selections-table #no-selections td {
            color: var(--selections-table-geodata-color);
            text-align: left;
        }
        .selections-table u {
            font-size: 0.8em;
            font-style: italic;
            text-decoration: none;
            letter-spacing: -0.1em;
        }
        .selections-table span {
            color: var(--selections-table-geodata-color);
            letter-spacing: -0.1em;
        }
        .selections-table button {
            width: auto;
            margin: 0 0 0 -0.2em;
            display: inline-block;
            width: 1.5em;
            height: 1.5em;
            padding: 0.05em 0.3em;
            text-align: center;
            border-radius: 99em;
        }
        .selections-table .delete:hover {
            color: var(--danger-color);
        }
        .download-all {
            display: flex;
            margin: 1em 0 0.3em 0;
        }
        .download-all button {
            margin: 0;
        }
        .download-all button:first-child {
            display: inline-block;
            width: 29em;
        }
        .download-all button:last-child {
            display: inline-block;
            width: 100%;
            margin-left: 0.5em;
        }

        /* USER'S GUIDE */
        .users-guide {
            position: fixed;
            top: 0;
            left: 0;
            height: 90vh;
            overflow: scroll;
            width: 40em;
            margin: 5vh 0 0 5vh;
            padding: 1em 4em 2em 2em;
            z-index: 10;
            background-color: var(--users-guide-background-color);
            box-shadow: 0.5em 0.5em 4em var(--users-guide-background-color);
            border-radius: 0.2rem;
            display: none;
        }
        .users-guide .hide {
            display: block;
            text-decoration: none;
            font-size: 3em;
            position: fixed;
            margin: -1rem 0 0 35rem;
            font-weight: 200;
        }
        .users-guide p.hero {
            font-size: 1.25em;
            margin: 0.5em 0;
        }
        .users-guide img,
        .users-guide video {
            max-width: 100%;
        }
        .users-guide .separator {
            margin-top: 1.5em;
            text-align: center;
        }
        .users-guide .separator img {
            width: 2.5em;
            margin: 0 0.2em;
        }
        h2 {
            font-weight: bold;
            text-transform: uppercase;
            font-size: 1.25em;
            margin-top: 1.25em;
        }
        h3 {
            font-weight: bold;
            font-style: italic;
            text-transform: uppercase;
            font-size: 1em;
            margin-top: 1em;
        }
        .users-guide .separator + h2,
        .users-guide .separator + h3 {
            margin-top: 1rem;
        }
        .users-guide table {
            border-spacing: 0;
        }
        .users-guide tr:first-child td {
            padding-top: 0;
        }
        .users-guide tr:last-child td {
            padding-bottom: 0;
        }
        .users-guide td {
            vertical-align: top;
            padding: 0.5em;
        }
        .users-guide table td:first-child {
            padding-left: 0;
            border-right: 1px solid var(--rule-color);
        }
        .users-guide table td:last-child {
            padding-right: 0;
        }
        .users-guide ol {
            margin-left: 1.82em;
        }
        .users-guide ol > li {
            margin: 1em 0;
        }
        .users-guide ul {
            margin: 0;
            list-style-type: none;
            padding-left: 1.9em;
        }
        .users-guide ul > li {
            text-indent: -1.82em;
            margin: 1em 0;
        }
        .users-guide ul > li:before {
            content: "—\a0\a0";
            text-indent: -2em;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
            /*box-shadow: 0 0 1em var(--precision-helper-background-color);*/
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* STATUS */
        .status {
            position: fixed;
            left: 0;
            bottom: 0;
            background-color: var(--status-background-color);
            padding: 0.5em;
            pointer-events: none;
            z-index: 10;
            opacity: 1;
            border-radius: 0 0.2rem 0 0;
        }
        .status.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* ERRORS */
        .error {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2em 5em 2em 2em;
            background-color: var(--error-background-color);
            z-index: 10;
        }
        .error-message {
            margin: 0;
        }
        .error .dismiss {
            display: block;
            text-decoration: none;
            font-size: 3em;
            position: fixed;
            right: 2rem;
            margin-top: -1.4rem;
            font-weight: 200;
        }
        .error.hidden {
            display: none;
        }

        /* MAIN CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background-color: var(--main-background-color);
        }
        #dropped-image, #cropped-image {
            display: none;
        }
        #base-image {
            position: absolute;
        }
        #work {
            position: absolute;
            display: block;
            height: 100vh;
            width: calc(100vw - var(--sidebar-width));
            cursor: crosshair;
        }

        /* MAIN DROPPER */
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
            width: calc(100vw - var(--sidebar-width));
            position: absolute;
        }
        .dropper-label {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 0.8em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 50%;
            min-width: 13em;
            margin: auto;
            margin-top: 25vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .dropper.active .dropper-label {
            background-color: inherit;
            filter: invert(1);
        }
        .drop-or-select {
            display: block;
            font-style: normal;
            cursor: pointer;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
            <svg viewBox="0 0 250 250" aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
            </svg>
        </a>
        <h1>
            Cr<svg viewBox="-105 -105 210 210" style="stroke: currentColor; stroke-dasharray: 21 14; stroke-width: 10; fill: none;">
                <image width="209" height="209" transform="translate(-104.5,-104.5)" xlink:href="data:image/gif;base64,R0lGODlhsgCyALMAABhHIyJNKw9IHRZQIhQ/ICpgMkZySlKFXtnl4zhoPAxCGhpdKDZYOCJWK3SWf////yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4zLWMwMTEgNjYuMTQ1NjYxLCAyMDEyLzAyLzA2LTE0OjU2OjI3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChNYWNpbnRvc2gpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkM3OUREQ0RDRTkyMTExRUE5Qjc2RENCNzZFODNFOTRGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkM3OUREQ0RERTkyMTExRUE5Qjc2RENCNzZFODNFOTRGIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6Qzc5RERDREFFOTIxMTFFQTlCNzZEQ0I3NkU4M0U5NEYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Qzc5RERDREJFOTIxMTFFQTlCNzZEQ0I3NkU4M0U5NEYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4B//79/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW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" />
                <path d="M0,0 L70.7,-70.7"></path>
                <circle cx="0" cy="0" r="100" />
            </svg>p
            <em>Circles</em>
        </h1>
        <p>A tool for cropping circular <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery.</p>

        <input id="upload-another-image" type="file" accept="image/*" style="display: none;">
        <div class="another-image-dropper hidden">
            Drop or <a>select</a> another image…
        </div>

        <span><strong>Usage:</strong> Provide an image, click and drag from a center point to make a selection, refine it with <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> <kbd>+</kbd> <kbd>-</kbd>, then press <kbd>enter</kbd> to download the cropped result. Rinse and repeat. <a href="javascript:showUsersGuide();">Learn more…</a></span>

        <section class="selections-table-container hidden">
            <hr>

            <p><span>The following reverse-chronological table lists your <strong id="selection-count">0 selections</strong> in this image, enabling redownloading (with different settings, say) and deletion.</span></p>

            <table class="selections-table">
                <thead>
                    <td>x →</td>
                    <td>y ↓</td>
                    <td>radius</td>
                    <td></td>
                </thead>
                <tbody id="selections-table-body"></tbody>
                <tfoot id="selections-table-foot"></tfoot>
                <tr id="no-selections">
                    <td colspan="4">No selections present.</td>
                </tr>
            </table>

            <div class="download-all-container">
                <div class="download-all">
                    <button onclick="downloadAll();">download all</button>
                    <button onclick="downloadZip();">…as zip</button>
                </div>
                <span>If you've made many selections in a massive image, zipping can be slower than just plain downloading all, but that, in turn, doesn't work in Safari.</span>
            </div>
        </section>

        <hr>

        <label><input type="checkbox" class="show-selections-checkbox" data-default="yes" onclick="updateShowSelections(this);" checked> show selections</label>
        <span>Shows <a href="javascript:showUsersGuide('ug-showselections');">previously selected</a> circles, which is helpful for keeping track of what you've already done.</span>

        <label>
            <input type="range" min="0.1" max="2.0" step="0.1" value="1.0" data-default="1.0" class="precision-helper-zoom-slider" oninput="adjustPrecisionHelperZoom(this)">
            <br>
            <b>1.0×</b>
            precision helper zoom
        </label>
        <span>Adjusts the zoom level of the thumbnails shown in the precision helper below.</span>

        <label><input type="checkbox" class="download-immediately-checkbox" data-default="yes" onclick="updateDownloadImmediately(this);" checked> download immediately</label>
        <span>Uncheck this if you prefer downloading your images through the table above <em>after</em> making a bunch of selections.</span>

        <input type="text" class="filename-template-field" data-default="" placeholder="FILENAME TEMPLATE" value="" oninput="updateFilenameTemplate(this)">
        <span>Template for the filenames of result images (but don't specify the file extension, it's added automatically). You can look up the list of template variables <a href="javascript:showUsersGuide('ug-filename');">in the user's guide</a>. If left empty, a <a href="javascript:showUsersGuide('ug-filename');">reasonable default</a> will be used.</span>

        <hr>

        <label><input type="checkbox" class="transparent-background-checkbox" data-default="yes" onclick="updateTransparentBackground(this);" checked> transparent background</label>
        <span>If <em>un</em>checked, the surroundings of the circular selection will be visible in the corners of the final images – <a href="javascript:showUsersGuide('ug-transparentbackground');">essentially</a>, this turns the selection into a rectangle. You can add some margin with the options below.</span>

        <section class="margin-settings disabled">
            <label>
                <input type="range" min="0.0" max="4.0" step="0.1" value="0.0" data-default="0.0" class="vertical-margin-slider" oninput="adjustVerticalMargin(this)" disabled>
                <br>
                <b>0·<em>r</em></b>
                vertical margin
            </label>
            <span>Above and below the circular core of the selection, include a vertical margin expressed as a fraction of the selection radius <em>r</em>.</span>

            <label>
                <input type="range" min="0.0" max="4.0" step="0.1" value="0.0" data-default="0.0" class="horizontal-margin-slider" oninput="adjustHorizontalMargin(this)" disabled>
                <br>
                <b>0·<em>r</em></b>
                horizontal margin
            </label>
            <span>Analogous to the vertical margin, but towards the left and right.</span>
            <label class="ceci-nest-pas-une-parametre">
                <b class="aspect-ratio">1:1</b>
                aspect ratio
            </label>
            <span>Your settings result in the aspect ratio shown above.</span>
        </section>

        <hr>

        <p><span>These <em>settings</em> are continually written to your browser's <em>local storage</em>, so they will likely be restored when you close and reopen this page – but that's up to your browser's caching policies. You can back them up here and restore a previous backup:</span></p>

        <section class="backup-restore">
            <button onclick="downloadSettings();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                back up
            </button>
            <input id="upload-settings" type="file" accept="application/json" style="display: none;">
            <button onclick="restoreSettings();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,10 L0,-10 M-10,0 L0,-10 L10,0"></path></svg>
                restore…
            </button>
        </section>
        <p><span>The same goes for your <em>selections</em>, both your current ones and ones you've made in previous sessions. This allows you to close this tool mid-work, reopen it, drag the same image in again, and continue selecting from where you left off – or a different image <a href="javascript:showUsersGuide('ug-geoawareness');">covering an area</a> you've previously made selections in. Again, your browser might decide to evict this data from its cache, hence:</span></p>
        <section class="backup-restore">
            <button onclick="downloadSelectionCache();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                back up
            </button>
            <input id="upload-selectioncache" type="file" accept="application/json" style="display: none;">
            <button onclick="restoreSelectionCache();">
                <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,10 L0,-10 M-10,0 L0,-10 L10,0"></path></svg>
                restore…
            </button>
        </section>

        <hr>

        <span class="reset">
            <strong>Danger zone:</strong> <a href="javascript:resetSettingsToDefaults();">reset settings</a> or <a href="javascript:purgeSelectionCache();">purge selection cache</a>, in which case only your current selections will remain, or <a href="javascript:deleteAllSelections();">delete all current selections</a>.
        </span>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>

    <main>
        <img id="base-image">
        <canvas id="work"></canvas>
        <div class="dropper">
            <div class="dropper-label">
                <input id="upload-image" type="file" accept="image/*" style="display: none;">
                <em class="drop-or-select">Drop or <a>select</a> image…</em>
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
    </main>

    <img id="dropped-image">
    <canvas id="cropped-image"></canvas>

    <footer class="status hidden"></footer>
    <footer class="error hidden">
        <a href="javascript:dismissError();" class="dismiss">×</a>
        <p class="error-message"></p>
    </footer>

    <section class="users-guide">
        <a href="javascript:hideUsersGuide();" class="hide">×</a>
        <p class="hero"><a href="https://github.com/doersino/cropcircles"><em>Crop Circles</em></a> is a tool originally designed for cropping circular <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery collected with, for example, <a href="https://github.com/doersino/aerialbot">ærialbot</a>.</p>
        <p>It's an unabashedly-built-for-<a href="https://noahdoersing.com">myself</a> tool, with precisely the knobs and toggles I thought would enable me to fine-tune my workflow during the creation of a <a href="https://www.youtube.com/playlist?list=PLTphPoE54a1s_ZdCkGwbhQO9O5SMSitA1">series of videos</a> like the one below.</p>

        <video controls loop poster="assets/video-poster-sample-sw42.286577541476696,-113.90409924217032ne42.340476458523305,-113.80691475782969.jpg">
            <source src="assets/video-sample-sw42.286577541476696,-113.90409924217032ne42.340476458523305,-113.80691475782969.mp4" type="video/mp4">
        </video>

        <p><em>But nothing's keeping you from using this tool to crop circular objects from imagery-in-a-more-general-sense!</em> To that end, I think it's helpful to spend a couple minutes reading this document, or, alternatively, discovering how this tool works through play – rest assured that you can't break anything.</p>

        <p class="separator"></p>

        <h2>Basic Usage</h2>
        <ol>
            <li>Drop an image into the <a href="javascript:showUsersGuide('ug-workarea');">main work area</a>.</li>
            <li>Click and drag from a center point to make a circular selection.</li>
            <li>Keeping an eye on the <a href="javascript:showUsersGuide('ug-precisionhelper');">precision helper</a> in the bottom right, adjust the selection with the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd>; you can increase or decrease the size of your selection with <kbd>+</kbd> <kbd>-</kbd>. Press <kbd>shift</kbd> to adjust in 20× larger increments.</li>
            <li>When satisfied, press <kbd>enter</kbd> to accept the selection – it will then download as a PNG image, tightly cropped around the x and y bounds of the circular selection, with transparent corners. (If you wish to cancel the current selection, press <kbd>esc</kbd>.)</li>
            <li>Repeat steps 2 through 4 for as many circles as you'd like to select.</li>
        </ol>

        <p class="separator"></p>

        <h2>User interface</h2>

        <h3 id="ug-workarea">Work area</h3>
        <p>Filling most of the screen, the main work area contains the active image (or, initially, a prompt to select one). You can use your mouse to create <em>selections</em>:</p>
        <ol>
            <li>Click at the desired selection center.</li>
            <li>Then drag without letting go of the left mouse button to make a circular selection.</li>
            <li>Once you let go of the left mouse button, the preliminary selection can be refined. Keeping an eye on the <em>precision helper</em> in the bottom right (more about that in a bit), adjust the selection with the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> (or with <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> if you feel particularly gamery today); you can increase or decrease the size of your selection with <kbd>+</kbd> <kbd>-</kbd> (or <kbd>P</kbd> <kbd>O</kbd> if you don't have math operators handy on your keyboard layout). Press <kbd>shift</kbd> at the same time to adjust things in 20× larger increments.</li>
            <li>
                Further selections can either be made in the same click-and-drag-and-refine manner, or by two other ways:
                <ul>
                    <li>Clicking-without-dragging a spot, which will replicate the most recent selection centered around that spot, ready to be refined.</li>
                    <li>Or by tapping one of <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> (or their gamer equivalents), which will replicate the most recent selection right next to itself in the cardinal direction determined by the pressed key.</li>
                </ul>
            </li>
        </ol>
        <p>Unless you uncheck the "show selections" setting, the work area also provides an overview over which fields (or other objects) you've already selected. Hovering the mouse pointer over one of them highlights it in the table in the sidebar.</p>

        <h3>Sidebar</h3>
        <p>The sidebar on the right, meanwhile, packs a punch: You can use it to…</p>
        <ul>
            <li>…open this user's guide. But you've already figured that out, it seems. Nice going!</li>
            <li>…select another image. Your selections in the current image will be kept around in the <a href="javascript:showUsersGuide('ug-selection-cache')">selection cache</a>: You can recover them by selecting the same image again, even after a page reload.</li>
            <li>…download or remove previous selections: Once you've made your first selection, a table listing your previous selections will appear in the sidebar. Read more about it below this list.</li>
            <li>…change the various settings detailed later in this document.</li>
            <li>…and export or restore your settings or the selection cache. This is also described later in this document.</li>
        </ul>

        <p>The <em>selections table</em> lists the selections you've made in the current image (plus, if it has <a href="javascript:showUsersGuide('ug-geoawareness');">associated geo data</a>, any selections you've made in other images that fall into the geographical area covered by the image). Hovering over a selection in the table highlights it in the main work area. Using the buttons in right-most column of the table, you can (re)download or delete a specific selection, or "accept" a selection you've previously made in another image that is located in the geographical area covered by the current image – this will copy it into the main part of the selections table (if you delete such a selection, it returns to the "geo suggestions" section at the bottom of the table).</p>
        <p>Recall that that the selections you've made in the current image are kept in the <a href="javascript:showUsersGuide('ug-selection-cache');">selection cache</a>, so this table will be restored if you work on another image, then select this one again.</p>
        <p>A pair of buttons below the table allows you to download all selections: Either sequentially, which I sadly haven't gotten to work reliably in Safari (only in Chrome and Firefox), or in a single ZIP file. Note that if you have made more than a few selections that cover a large area (say, 1 megapixel each), zipping can be slower than downloading them all individually or sequentially – that seems to be a limitation of the <a href="https://github.com/Stuk/jszip/">JSZip</a> library.</p>

        <h3 id="ug-precisionhelper">Precision helper</h3>
        <p>Below the sidebar, the <em>precision helper</em> aids you in hitting your marks when making a selection. It's divided into nine areas:</p>
        <ul>
            <li>The central square shows the central portion of the selection. A crosshairs trained on the very center pixel helps with alignment. Another line protrudes from the middle of each of the sides of this square, this is mostly just handy when working on images of center pivot irrigation farms.</li>
            <li>The four squares right above, below, right, and left of the central square show the areas of the image near the top, bottom, right, and left selection boundaries.</li>
            <li>The corner squares show the areas of the image at the 1:30, 4:30, 7:30, and 10:30 positions with regard to the selection.</li>
        </ul>

        <h3>User's guide</h3>
        <p>The user's guide should be self-explanatory (literally!).</p>

        <h3>Status & error messages</h3>
        <p>Status messages may pop up in the bottom left corner and inform you about ongoing processes like zipping, or, say, about successful selection cache restores. They disappear automatically, either two seconds after being summoned or after the process they're keeping your updated on has finished.</p>
        <p>Error messages, should they appear, cover the bottom part of the screen, are roughly the same shade of red as the two <a href="https://twitter.com/ScuderiaFerrari/status/1304113260124344325">SF1000</a> cars that raced around the Mugello circuit on the weekend of this tool's initial release, and don't disappear automatically. (If you want to experience one, simply try to restore your settings from some random file instead of a proper backup.)</p>

        <p class="separator"></p>

        <h2>Keyboard Controls</h2>

        <p>Even though most of the keyboard controls have been described in the previous section, here's a table summarizing their functions:</p>

        <table>
            <tr>
                <td><kbd>↑</kbd>, <kbd>W</kbd></td>
                <td>Move the current selection upwards by a pixel (or 20 if <kbd>shift</kbd> is pressed), or if there is no current selection, make a copy of the most recent selection right above itself that can then be further refined.<br>
                If you're using a <em>non-qwerty key layout</em>, <kbd>W</kbd> probably (i.e. if your browser abides by the standards) won't do anything: Instead, press the key that's located where the <kbd>W</kbd> key would be on a conventional key layout (the same goes for all other letter keys). It's implemented <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code">that way</a> because I'm told that's how you'll expect it to work. ¯\_(ツ)_/¯</td>
            </tr>
            <tr>
                <td><kbd>↓</kbd>, <kbd>S</kbd></td>
                <td>Analogous, but downwards.</td>
            </tr>
            <tr>
                <td><kbd>←</kbd>, <kbd>A</kbd></td>
                <td>Analogous, but leftwards.</td>
            </tr>
            <tr>
                <td><kbd>→</kbd>, <kbd>D</kbd></td>
                <td>Analogous, but rightwards.</td>
            </tr>
            <tr>
                <td><kbd>+</kbd>, <kbd>P</kbd></td>
                <td>Increase the radius of the current selection by a pixel (or 20 if <kbd>shift</kbd> is pressed).</td>
            </tr>
            <tr>
                <td><kbd>-</kbd>, <kbd>O</kbd></td>
                <td>Analogous, but this decreases the radius.</td>
            </tr>
            <tr>
                <td><kbd>*</kbd></td>
                <td>Analogous to <kbd>shift</kbd> <kbd>+</kbd> because I'm using a German key layout, and one of the perks of building your own tools is that you can account for your edge cases with hacks instead of having to look for more elegant solutions.</td>
            </tr>
            <tr>
                <td><kbd>_</kbd></td>
                <td>Analogous to <kbd>shift</kbd> <kbd>-</kbd> for the same reason.</td>
            </tr>
            <tr>
                <td><kbd>shift</kbd></td>
                <td>Increase the potency of the previous operations by a factor of 20. Your key switches will be grateful.</td>
            </tr>
            <tr>
                <td><kbd>enter</kbd></td>
                <td><em>Accept</em> the current selection, thereby freezing its size and location and adding it to both the table in the sidebar and the selection cache.</td>
            </tr>
            <tr>
                <td><kbd>backspace</kbd></td>
                <td>Delete the most recently accepted selection. Note that this is irreversible, and pressing <kbd>backspace</kbd> multiple times will delete multiple selections. Be careful (or make frequent <a href="javascript:showUsersGuide('ug-backups');">backups</a>)!</td>
            </tr>
            <tr>
                <td><kbd>esc</kbd></td>
                <td>Cancel the current selection.</td>
            </tr>
        </table>

        <p>All of these are disabled while you're entering text into the <a href="javascript:showUsersGuide('ug-filename');">filename template field</a>, of course.</p>

        <p class="separator"></p>

        <h2>Configuration</h2>

        <p>The settings in the sidebar are tersely explained in-place. Here's some more words about them.</p>

        <h3 id="ug-showselections">Show selections</h3>
        <p>If enabled (which is the default), your previously selected circles are visible in the main work area, which is helpful for keeping track of what you've already done. If the current image has <a href="javascript:showUsersGuide('ug-geoawareness');">associated geo data</a>, selections you've previously made in other images that fall into the geographical area covered by the current image will show up, too.</p>

        <h3>Precision helper zoom</h3>
        <p>Adjusts the zoom level of the thumbnails shown in the precision helper in the bottom right. At 1×, the image pixels will be shown at original scale with regard to <em>logical</em> browser pixels – on a high-DPI or Retina device, they will thus be scaled up with regard to <em>physical</em> pixels. This is by design.</p>

        <h3>Download immediately</h3>
        <p>Uncheck this checkbox if you prefer downloading your images through the selections table after first making a bunch of selections.</p>

        <h3 id="ug-filename">Filename</h3>

        <p>This is a template for the filenames of result images. It's used both for direct downloads and filenames within ZIPs. Make sure <em>not to</em> specify the file extension, it's added automatically depending on other settings. If you leave this field empty, as is indeed the default, the default filename template (see first row of the following table) is used.</p>
        <p>You can make use of the following variables:</p>

        <table>
            <tr>
                <td>{default}</td>
                <td>The default filename: "cropcircles-x{x}y{y}r{r}" (or "cropcircles-{lat},{lon},{rm}m-x{x}y{y}r{r}" if the current image has associated geo data). Handy if all you want to change is adding a prefix or postfix.</td>
            </tr>
            <tr>
                <td>{file}</td>
                <td>Filename of the image the selection was made in.</td>
            </tr>
            <tr>
                <td>{id}</td>
                <td>Internal selection identifier, actually the millisecond-precision UNIX timestamp at which the selection was made, e.g. "1599251366699".</td>
            </tr>
            <tr>
                <td>{date}</td>
                <td>The current date at the time of download, in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString">simplified extended ISO format</a>, e.g. "2020-09-12T18.51.17.485Z".</td>
            </tr>
            <tr>
                <td>{rand}</td>
                <td>Random integer with a (zero-padded) length of 10. E.g. "1708473213" or "0072495286". Handy as a filename prefix if you want the images to end up in a random order for whatever reason.</td>
            </tr>
            <tr>
                <td>{x}</td>
                <td>x coordinate, in pixels and with respect to the top left corner of the image, of the selection center.</td>
            </tr>
            <tr>
                <td>{y}</td>
                <td>Analogous.</td>
            </tr>
            <tr>
                <td>{r}</td>
                <td>Radius of the circular selections, in pixels.</td>
            </tr>
        </table>

        <p>If the current image has <a href="javascript:showUsersGuide('ug-geoawareness');">associated geo data</a>, the following variables are available, as well:</p>

        <table>
            <tr>
                <td>{georect}</td>
                <td>Geo bounds of the input image, e.g. "sw42.2865,-113.9040ne42.3404,-113.8069". This allows you to drop a cropped image right back into this tool and, say, tighten the existing selection.</td>
            </tr>
            <tr>
                <td>{lat}</td>
                <td>Latitude of the selection center.</td>
            </tr>
            <tr>
                <td>{lon}</td>
                <td>Analogous.</td>
            </tr>
            <tr>
                <td>{rm}</td>
                <td>Selection radius in meters. (Note that the scale factor from pixels to meters depends on latitude.)</td>
            </tr>
        </table>

        <h3 id="ug-transparentbackground">Transparent background</h3>
        <p>If you leave this checkbox enabled, downloading your selections will yield PNG images with transparent corners: anything outside the bounds of the circular selections will be removed (like each of the three little center pivot irrigation farms in-between the sections of this user's guide).</p>
        <p>On the other hand, if you choose to uncheck this checkbox, the <em>surroundings</em> of the circular selections will be visible in the corners of the final images – essentially, this turns the selection into a square. This square can be expanded into a rectangle that includes even more of the circular selection's surroundings through the following two settings. Since this removes the need for transparency, the images are downloaded as more space-efficient JPG files. The encoding quality is set at 100%, making this effectively as lossless as PNG.</p>
        <p>This functionality comes in handy for making a video like the one at the top of this user's guide, where different circular objects are shown in one place, with mainly their surroundings changing.</p>
        <p>If enabled, you'll notice a box-shaped dashed line around the current (or highlighted) selection – that's just a preview of the crop area.</p>

        <h3>Vertical margin</h3>
        <p>If you increase this slider from its default of 0, a vertical margin whose size you can set as a fraction of the selection radius is added above and below the circular core of the selection.</p>

        <h3>Horizontal margin</h3>
        <p>Analogous to the vertical margin, but towards the left and right.</p>
        <p>Together, these two sliders allow you to dial in the range of surroundings to include in the images: For the example video included at the beginning of this document, the vertical margin was set to 0.2 and the horizontal margin to 1.8, yielding an aspect ratio (as shown below the two sliders) of 1:2.33 (i.e. <a href="https://en.wikipedia.org/wiki/CinemaScope">cinemascope</a>).</p>

        <p class="separator"></p>

        <h2 id="ug-backups">Backup & Restore</h2>

        <p>Using the buttons near the bottom of the sidebar, you can download a backup of your settings or the selection cache. These backups take the form of JSON files – you can inspect and modify them in any text editor; their structure is simple enough that you won't need further information about their schemata.</p>

        <p>These backups would be pretty bad at being backups if you couldn't restore them, so you can! Note the differing semantics:</p>
        <ul>
            <li>If you restore a settings backup, the current settings are discarded and replaced with the settings stored in the backup.</li>
            <li>When restoring a selection cache backup, on the other hand, any selections from the backup that aren't already in the current selection cache are <em>added</em> to it – nothing is removed from the current selection cache. In math-y terms, that's the <em>union</em> of the two selection caches.</li>
            <li>If you would rather <em>replace</em> the current selection cache with the one from your backup, simply purge the current selection cache using the tiny little link at the very bottom of the sidebar (and, if you want, delete all current selections using the link nearby) before restoring the backup.</li>
        </ul>
        <p>Because settings and selection cache are stored in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">local storage</a>, which – depending on your browser settings – may be wiped occasionally, I recommend making occasional backups, <em>especially</em> of your selection cache.</p>

        <p class="separator"></p>

        <h2 id="ug-selection-cache">Selection cache</h2>
        <p>As outlined in previous sections of this user's guide, the selection cache is where your selections are safeguarded against inadvertent page reloads, browser crashes, or potential data loss when working on another image for a bit before resuming work on a previously worked-on image. To this end, the selection cache is kept in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">local storage</a> and can be <a href="javascript:showUsersGuide('ug-backups');">backed up and restored</a>.</p>
        <p>Each selection is assigned to the image it was made in. For simplicity's sake, sameness of two images is defined through equality of filename, filesize, and image width/height in pixels – so avoid situations where nominally-different images share all four of these attributes if you don't want selections made in one of them show up for the other one, as well.</p>
        <p>The subset of the selection cache belonging with the current image is shown in the selections table.</p>
        <p>It can be purged (for all images you've ever made selections in!) using a link at the very bottom of the sidebar.</p>

        <p class="separator"></p>

        <h2 id="ug-geoawareness">Geo-Awareness</h2>
        <p>Since this tool was designed for use with aerial imagery, it seemed to make sense to loop any geo data associated with that imagery all the way through the pipeline, embedding it into the output images. In my own use case, I'm not actually doing anything with that data, but maybe that'll change in future.</p>
        <p>Geo data, in the context of this tool, refers to latitude and longitude of the center points of the circular selections, which can be derived from the latitude and longitude of two points in the input image (and hardcoded assumptions about the projection the imagery uses). For simplicity's sake, these two points must be the southwest and northeast corners of the image:</p>
        <p>If the input image's filename contains a part of the form "sw[lat],[lon]ne[lat],[lon]", the cropped circles will be named based on their center point's latitude, longitude and circle radius (that one in meters). This interpolation is based on the assumption that the aerial imagery you've uploaded is laid out based on the Web Mercator projection, which is common among online mapping services like Google Maps. Even if that's not the case: On large-scale maps (covering fewer than 100 vertical kilometers), the difference will be in the rounding error range.</p>
        <p>If geo data is known for the current image, additional output filename variables are unlocked, and the default template also changes. Read more about that <a href="javascript:showUsersGuide('ug-filename');">here</a>.</p>
        <p>Also, latitude, longitude and radius in meters are shown in the selections table in the sidebar. Selections you make in images with associated geo data will also show up in other images covering the same area, with a dashed border. They are not automatically merged into the list of of selections of that image, instead they can be "promoted" though the selections table in the sidebar.</p>

        <p class="separator"></p>

        <h2>Notes</h2>
        <p>None of these bullet points fit well into the previous sections, so here they are:</p>
        <ul>
            <li>Check out <a href="https://github.com/doersino/aerialbot">ærialbot</a>, a Python-based tool that, while originally designed to run Twitter bots, can be used to download large-scale satellite maps of arbitrary areas. The sample image was obtained using ærialbot, for instance.</li>
            <li>Keep the images you "upload" below 100 megapixels – things get sluggish fast if you shoot past this limit. Then again, I've developed and tested this tool using a 5-year-old laptop, and I have a horrendous habit of keeping way too much stuff open in the background, burning CPU cycles that would otherwise be used by this tool, so your mileage may vary.</li>
            <li>The sample video shown at the top of this user's guide was generated (based on selections made in a higher-resolution variant of the sample image) using the venerable <a href="https://ffmpeg.org">FFmpeg</a> utility, invoked as follows: ffmpeg -framerate 3 -pattern_type glob -i '*.jpg' -vf scale=1920:824 -pix_fmt yuv420p out.mp4</li>
            <li>If you have opinions about this tool, whether they range from grandfatherly approval to the esteem in which conservatives seem to hold epidemiology, <a href="https://github.com/doersino/cropcircles/issues/new">tell me about them</a>! Any constructive feedback will probably be implemented swiftly (unless that'd be too much work).</li>
        </ul>

        <p class="separator"></p>

        <h2>Privacy Policy</h2>
        <p>There isn't any server communication beyond the initial page load, so you should be safe. No analytics or trackers either. This tool is hosted on GitHub Pages, so I don't even have access to web server logs (but GitHub <a href="https://docs.github.com/en/github/site-policy/github-privacy-statement">"may collect User Personal Information […], including logs of visitor IP addresses"</a>).</p>
        <p>Since your settings and selection cache are kept in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">local storage</a> as part of your browser cache, other pages you load though the same protocol-domain-port combination may access them. That's probably not something you need to worry about, though.</p>
        <p>But, in the words of the inimitable LeVar Burton, <em>you don't have to take my word for it</em>: Just <a href="https://github.com/doersino/cropcircles/archive/master.zip">download this tool</a>, disconnect your device from the internet, open the tool in an incognito window, do your work, close the window, delete your local copy of the tool, then enable wifi again.</p>

        <p class="separator"></p>

        <h2>Credit</h2>
        <p>Building this tool would have been more difficult than it turned out to be if it wasn't for the work of others, including but not limited to the following.</p>
        <ul>
            <li>The typeface used in the tool is <a href="https://github.com/be5invis/Iosevka/"><em>Iosevka Aile</em> by Belleve Invis</a>. It is licensed under the <em>SIL Open Font License Version 1.1</em>, see <a href="https://github.com/be5invis/Iosevka/blob/master/LICENSE.md">here</a>.</li>
            <li>Zipping is done with <a href="https://github.com/Stuk/jszip/">JSZip</a> in accordance with its <em>MIT License</em>, see <a href="https://github.com/Stuk/jszip/blob/master/LICENSE.markdown">here</a>.</li>
            <li>The general layout has been adapted from <a href="https://github.com/doersino/markdeep-diagram-drafting-board">Markdeep Diagram Drafting Board</a>, a previous project of mine.</li>
            <li>The source code of Craciun Cezar's <a href="https://github.com/craciuncezar/Simple-web-image-editor">Simple Web Image Editor</a> was referenced during the implementation of some key features.</li>
            <li>The sample image, from which all of the examples in this user's guide have been derived, has been downloaded from <a href="https://www.google.com/maps/place/42°18'48.7%22N+113°51'19.8%22W/@42.3135278,-113.8576887,6000m/">Google Maps</a> using <a href="https://github.com/doersino/aerialbot">ærialbot</a>.</li>
            <li>The same <a href="https://www.google.com/maps/place/43°37'03.8%22N+113°24'21.7%22W/@43.6154232,-113.4144375,2892m/">goes</a> for the logo background image, which has additionally been edited and optimized with Adobe Photoshop CS6.</li>
            <li>All of the code was written in <a href="https://www.sublimetext.com">Sublime Text</a>, the <a href="https://git-scm.com">Git</a> commits were almost exclusively authored in <a href="https://www.sublimemerge.com">Sublime Merge</a>, and testing was primarily carried out in Safari on macOS Mojave.</li>
            <li><em>Black Lives Matter.</em> That's not as unrelated as you might think: Black slaves were forced to do farm work, which enriched white land owners, many of which surely later used portions of that money to install the center pivot irrigation systems this tool was inspired by.</li>
        </ul>

        <img src="assets/readme-collage-1.jpg">
    </section>
    </section>

    <script src="assets/jszip/25d401e/dist/jszip.min.js"></script>
    <script>
        /////////////
        // GLOBALS //
        /////////////

        let dpr = null;
        let scale = null;
        let geoRect = null;

        let currentlySelecting = false;
        let currentSelection = null;

        let highlightedSelectionId = null;

        let selections = [];

        let selectionCache = [];
        let relevantGeoSelections = [];

        let imageInfo = {
            name: null,
            size: null,
            width: null,
            height: null,
            fileid: null
        };

        let precisionHelper = document.getElementById("prec");
        let work = document.getElementById("work");
        let image = document.getElementById("dropped-image");


        /////////////
        // HELPERS //
        /////////////

        // via https://gist.github.com/luciopaiva/01bda0d4311ccaecea0478ad2fd03108
        function readCssVar(name) {
            name = name.startsWith("--") ? name : "--" + name;
            return window.getComputedStyle(document.documentElement).getPropertyValue(name);
        }

        function logicalCanvasToImage(n) {  // for mouse tracking
            return n * dpr / scale;
        }
        function imageToLogicalCanvas(n) {  // for image sizing
            return scale * n / dpr;
        }
        function imageToPhysicalCanvas(n) {  // for selection drawing
            return n * scale;
        }
        function logicalCanvastoPhysicalCanvas(n) {  // primarily for line strength scaling
            return n * dpr;
        }
        function physicalCanvastoLogicalCanvas(n) {  // primarily for precision helper image scaling
            return n / dpr;
        }

        function radians(x) {
            return x * Math.PI / 180;
        }
        function degrees (x) {
            return x * 180 / Math.PI;
        }
        let earthCircumference = 40075.016686 * 1000;  // in meters, at the equator

        function setupCanvas(elem) {

            // set height and width correctly on retina devices
            let w = elem.offsetWidth;
            let h = elem.offsetHeight;
            elem.style.width = w + "px";
            elem.style.height = h + "px";
            elem.setAttribute("width", logicalCanvastoPhysicalCanvas(w));
            elem.setAttribute("height", logicalCanvastoPhysicalCanvas(h));
        }

        function download(url, filename) {
            let dummyLink = document.createElement("a");
            dummyLink.setAttribute("href", url);
            dummyLink.setAttribute("download", filename);
            dummyLink.style.display = "none";
            document.body.appendChild(dummyLink);
            dummyLink.click();
            document.body.removeChild(dummyLink);
        }

        //////////////////
        // CANVAS SETUP //
        //////////////////

        function setupPrecisionHelper() {
            setupCanvas(prec);
            renderPrecisionHelper();
        }

        function setupWork() {
            setupCanvas(work);
        }


        ////////////////////
        // CANVAS DRAWING //
        ////////////////////

        function renderPrecisionHelper() {
            let pc = precisionHelper.getContext("2d");
            let W = precisionHelper.width;
            let H = precisionHelper.height;
            let w = physicalCanvastoLogicalCanvas(W);
            let h = physicalCanvastoLogicalCanvas(H);

            pc.clearRect(0, 0, W, H);

            pc.lineWidth = logicalCanvastoPhysicalCanvas(1);
            pc.strokeStyle = readCssVar("current-selection-stroke");

            if (currentSelection) {

                // there's 3x3 squares, each of which receives a different-but-similar treatment. it's possible to express this with two nested loops and a bunch of unintuitive index computation, but if you scroll back through the git history, you'll find a more verbose, imperative variant
                [-1, 0, 1].forEach(x => {
                    [-1, 0, 1].forEach(y => {

                        // draw square from images
                        let r = currentSelection.r;
                        if (x != 0 && y != 0) {
                            r /= Math.sqrt(2);
                        }
                        pc.drawImage(
                            image,
                            currentSelection.x + (x * r) - w/6 / settings.precisionHelperZoom,
                            currentSelection.y + (y * r) - h/6 / settings.precisionHelperZoom,
                            w/3 / settings.precisionHelperZoom,
                            h/3 / settings.precisionHelperZoom,
                            (1 + x) * W/3,
                            (1 + y) * H/3,
                            W/3,
                            H/3
                            );

                        // draw circle section (or, for the center square, alignment marks)
                        if (x == 0 && y == 0) {
                            pc.beginPath();
                            // cross
                            pc.moveTo(W/2-W/18, H/2-H/18);
                            pc.lineTo(W/2-W/54, H/2-H/54);
                            pc.moveTo(W/2+W/54, H/2+H/54);
                            pc.lineTo(W/2+W/18, H/2+H/18);
                            pc.moveTo(W/2+W/18, H/2-H/18);
                            pc.lineTo(W/2+W/54, H/2-H/54);
                            pc.moveTo(W/2-W/54, H/2+H/54);
                            pc.lineTo(W/2-W/18, H/2+H/18);
                            // dot
                            let dotRadius = logicalCanvastoPhysicalCanvas(1);
                            pc.rect(W/2-dotRadius/2, H/2-dotRadius/2, dotRadius, dotRadius);
                            // lines at the edges
                            pc.moveTo(W/2, H/3);
                            pc.lineTo(W/2, H/3+H/18);
                            pc.moveTo(W/2, 2*H/3);
                            pc.lineTo(W/2, 2*H/3-H/18);
                            pc.moveTo(W/3, H/2);
                            pc.lineTo(W/3+W/18, H/2);
                            pc.moveTo(2*W/3, H/2);
                            pc.lineTo(2*W/3-W/18, H/2);
                            pc.stroke();
                        } else {
                            // here, logicalCanvastoPhysicalCanvas(r) is correct since the image is show at 1x (modulo zoom) as opposed to being fitted into the viewport
                            let radius = logicalCanvastoPhysicalCanvas(currentSelection.r) * settings.precisionHelperZoom;
                            r = radius;
                            if (x != 0 && y != 0) {
                                r /= Math.sqrt(2);
                            }

                            pc.save();
                            pc.beginPath();
                            pc.rect(
                                (1 + x) * W/3,
                                (1 + y) * H/3,
                                W/3,
                                H/3);
                            pc.closePath();
                            pc.clip();
                            pc.beginPath();
                            pc.arc(
                                W/2 + x * (W/3 - r),
                                H/2 + y * (H/3 - r),
                                radius,
                                0,
                                2 * Math.PI
                                );
                            pc.stroke();
                            pc.restore();
                        }
                    });
                });
            }

            // borders: two on each axis
            pc.beginPath();
            [1, 2].forEach(n => {
                pc.moveTo(n*W/3, 0);
                pc.lineTo(n*W/3, H);
                pc.moveTo(0, n*H/3);
                pc.lineTo(W, n*H/3);
            });
            pc.lineWidth = logicalCanvastoPhysicalCanvas(2);
            pc.strokeStyle = readCssVar("precision-helper-dividers-stroke");
            pc.stroke();
        }

        function renderWork() {
            let wc = work.getContext("2d");

            let setLineDash = (on, off) => {
                if (!on) {
                    wc.setLineDash([]);
                } else {
                    wc.setLineDash([logicalCanvastoPhysicalCanvas(on), logicalCanvastoPhysicalCanvas(off)]);
                }
            }
            let drawSelectionCircle = s => {
                wc.arc(imageToPhysicalCanvas(s.x), imageToPhysicalCanvas(s.y), imageToPhysicalCanvas(s.r), 0, 2 * Math.PI);
            };
            let drawSelectionRadius = s => {
                wc.moveTo(imageToPhysicalCanvas(s.x), imageToPhysicalCanvas(s.y));
                wc.lineTo(imageToPhysicalCanvas(s.px), imageToPhysicalCanvas(s.py));
            }
            let drawSelectionMargins = s => {
                wc.rect(
                    imageToPhysicalCanvas(s.x - (settings.horizontalMargin + 1) * s.r),
                    imageToPhysicalCanvas(s.y - (settings.verticalMargin + 1) * s.r),
                    imageToPhysicalCanvas((2 * settings.horizontalMargin + 2) * s.r),
                    imageToPhysicalCanvas((2 * settings.verticalMargin + 2) * s.r)
                    );
            }

            wc.clearRect(0, 0, work.width, work.height);
            wc.lineWidth = logicalCanvastoPhysicalCanvas(1);

            if (currentSelection) {
                wc.strokeStyle = readCssVar("current-selection-stroke");

                setLineDash(6, 4);
                wc.beginPath();
                drawSelectionCircle(currentSelection);
                drawSelectionRadius(currentSelection);
                wc.stroke();
                setLineDash();

                if (!settings.transparentBackground) {
                    setLineDash(2, 4);
                    wc.beginPath();
                    drawSelectionMargins(currentSelection);
                    wc.stroke();
                    setLineDash();
                }
            }

            if (settings.showSelections) {
                wc.strokeStyle = readCssVar("selections-stroke");
                wc.fillStyle = readCssVar("selections-fill");

                // don't yet draw the highlighted one
                selections.filter(s => s.id != highlightedSelectionId).forEach(sel => {
                    wc.beginPath();
                    drawSelectionCircle(sel);
                    wc.fill();
                    wc.stroke();
                });

                // show relevant geo selections from other images
                wc.strokeStyle = readCssVar("selections-stroke");
                wc.fillStyle = "transparent";
                setLineDash(3, 6);
                relevantGeoSelections.filter(s => s.id != highlightedSelectionId).forEach(sel => {
                    wc.beginPath();
                    drawSelectionCircle(sel);
                    wc.fill();
                    wc.stroke();
                });
                setLineDash();
            }

            if (highlightedSelectionId) {
                let sel = getSelection(highlightedSelectionId);

                // try geo selections
                let isGeo = false;
                if (!sel) {
                    sel = getRelevantGeoSelection(highlightedSelectionId);
                    isGeo = true;
                }

                // note: it's possible for there to not be a selection for the passed id iff the user has just deleted a selection through the table in the sidebar – before the table row disappears, the mouseover event is fired at least one more time, calling this function, hence we need to check if there's actually a selection
                if (sel) {
                    wc.strokeStyle = readCssVar("highlighted-selection-stroke");
                    wc.fillStyle = readCssVar("highlighted-selection-fill");

                    if (isGeo) {
                        setLineDash(3, 6);
                    }
                    wc.beginPath();
                    drawSelectionCircle(sel);
                    //drawSelectionRadius(sel);
                    wc.fill();
                    wc.stroke();
                    setLineDash();

                    if (!settings.transparentBackground) {
                        wc.beginPath();
                        setLineDash(2, 4);
                        drawSelectionMargins(sel);
                        wc.stroke();
                        setLineDash();
                    }
                }
            }
        }


        ///////////////////
        // GEO-AWARENESS //
        ///////////////////

        function extractAndSetGeoRect(filename) {

            // shoutout to https://regexr.com
            let regex = /sw(-?\d+.\d+),(-?\d+.\d+)ne(-?\d+.\d+),(-?\d+.\d+)/;
            let match = filename.match(regex);
            if (match && match.length == 5) {
                geoRect = {
                    sw: {
                        lat: parseFloat(match[1]),
                        lon: parseFloat(match[2])
                    },
                    ne: {
                        lat: parseFloat(match[3]),
                        lon: parseFloat(match[4])
                    }
                };
            }
        }

        // note: x, y must be in in image space. this function is correct if the imagery follows the web mercator projection, which most online mapping services use (i.e. which aerialbot emits).
        function getLatLon(x, y) {

            // invert y (since image y increases from top to bottom, but latitude increases from bottom to top)
            y = image.height - y;

            // relativize
            x /= image.width;
            y /= image.height;

            // this doesn't handle the possiblity of the geoRect running through the +-180° lon line, but that's not gonna happen in actual use
            let west = geoRect.sw.lon;
            let east = geoRect.ne.lon;
            let width = east - west;
            let lon = west + width * x;

            let north = radians(geoRect.ne.lat);
            let south = radians(geoRect.sw.lat);
            let lat = degrees(Math.asin(y * (Math.sin(north) - Math.sin(south)) + Math.sin(south)));

            return {lat: lat, lon: lon};
        }

        function getXY(lat, lon) {
            let west = geoRect.sw.lon;
            let east = geoRect.ne.lon;
            let width = east - west;
            let x = (lon - west) / width;

            let north = radians(geoRect.ne.lat);
            let south = radians(geoRect.sw.lat);
            let y = (Math.sin(radians(lat)) - Math.sin(south)) / (Math.sin(north) - Math.sin(south));

            x *= image.width;
            y *= image.height;

            y = image.height - y;

            return {x: x, y: y};
        }

        function getMetersPerPixel(lat) {
            return ((earthCircumference / image.width) * Math.cos(radians(lat))) / (360 / (geoRect.ne.lon - geoRect.sw.lon));
        }

        // gets the length of n (image space pixels) in meters at lat
        function getMeters(lat, px) {
            return getMetersPerPixel(lat) * px;
        }

        function getPixels(lat, m) {
            return m / getMetersPerPixel(lat);
        }


        ///////////////////////
        // IMAGE (RE)LOADING //
        ///////////////////////

        let dropper = document.querySelector('.dropper');
        dropper.addEventListener('dragover', e => {
            e.preventDefault();
            dropper.classList.add("active");
        });
        dropper.addEventListener('dragleave', e => {
            e.preventDefault();
            dropper.classList.remove("active");
        });
        dropper.addEventListener('drop', e => {
            dropImage(e);
            dropper.classList.remove("active");
        });
        document.querySelector('.drop-or-select').addEventListener('click', e => {
            e.preventDefault();
            document.getElementById("upload-image").click();
        });
        document.getElementById("upload-image").addEventListener('change', pickImage);

        let anotherImageDropper = document.querySelector('.another-image-dropper');
        anotherImageDropper.addEventListener('dragover', e => {
            e.preventDefault();
            anotherImageDropper.classList.add("active");
        });
        anotherImageDropper.addEventListener('dragleave', e => {
            e.preventDefault();
            anotherImageDropper.classList.remove("active");
        });
        anotherImageDropper.addEventListener('drop', e => {
            dropImage(e);
            anotherImageDropper.classList.remove("active");
        });
        anotherImageDropper.addEventListener('click', e => {
            e.preventDefault();
            document.getElementById("upload-another-image").click();
        });
        document.getElementById("upload-another-image").addEventListener('change', pickImage);

        function dropImage(e) {
            e.preventDefault();
            setStatus("Setting up image…", true);

            let files = e.dataTransfer.files;
            if (files.length == 1) {

                let file = files[0];

                if (!file.type.includes("image")) {
                    showError("It seems like \"" + file.name + "\" isn't an image, so I don't know what to do with it. Please drop an image instead.");
                    clearStatus();
                    return;
                }

                processDroppedOrPickedImage(file);
            } else {
                clearStatus();
                showError("It seems like you've dropped " + files.length + " files. Please drop only one.");
            }
        }

        function pickImage(e) {
            setStatus("Setting up image…", true);

            let files = e.target.files;

            // the missing "multiple" html attribute prevents more than one file from bein uploaded, and the "accept" attribute makes sure only images can be selected, so we don't need to handle the same errors as for dropping
            let file = files[0];
            processDroppedOrPickedImage(file);

            e.target.value = "";
        }

        function processDroppedOrPickedImage(file) {
            imageInfo.name = file.name;
            imageInfo.size = file.size;

            let reader = new FileReader();
            reader.onload = e => {
                installImage(e.target.result);
                clearStatus();
            };
            reader.readAsDataURL(file);
        }

        document.querySelector('.load-sample').addEventListener('click', e => {
            e.preventDefault();
            setStatus("Setting up sample image…", true);
            let filename = "assets/sample-sw42.286577541476696,-113.90409924217032ne42.340476458523305,-113.80691475782969.jpg";

            imageInfo.name = filename;
            imageInfo.size = 7383532;

            installImage(filename);
            clearStatus();
        });

        // receives either a path or a base64-encoded value
        function installImage(src) {

            // show the image selector in the side bar upon first image selection
            document.querySelector(".another-image-dropper").classList.remove("hidden");

            // store the image in a hidden img tag
            image.addEventListener('load', e => {
                document.querySelector(".dropper").style.display = "none";
                scale = null;
                drawNewImage();
                geoRect = null;
                extractAndSetGeoRect(imageInfo.name);
                currentlySelecting = false;
                currentSelection = null;
                highlightedSelectionId = null;
                selections = [];
                relevantGeoSelections = [];
                clearTable();
                recoverSelectionsFromSelectionCache();
                extractRelevantGeoSelectionsFromSelectionCache();
                renderWork();
                renderPrecisionHelper();  // clear it in case there was a currentSelection in the previous image
            });
            image.setAttribute("src", src);
        }

        function drawNewImage() {
            imageInfo.width = image.width;
            imageInfo.height = image.height;
            imageInfo.fileid = btoa(imageInfo.name + imageInfo.size + imageInfo.width + imageInfo.height);

            let scaleX = work.width / image.width;
            let scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);

            let baseImage = document.getElementById("base-image");
            baseImage.setAttribute("src", image.src);
            baseImage.setAttribute("width", imageToLogicalCanvas(image.width))
            baseImage.setAttribute("height", imageToLogicalCanvas(image.height));

            renderWork();
        }


        ///////////////////////
        // SELECTION HELPERS //
        ///////////////////////

        function acceptCurrentSelection() {
            if (!currentSelection) {
                return;
            }

            let sel = {
                id: Date.now(),
                fileid: imageInfo.fileid,
                x: currentSelection.x,
                y: currentSelection.y,
                px: currentSelection.px,
                py: currentSelection.py,
                r: currentSelection.r,
                geo: false
            };

            if (geoRect) {
                let latlon = getLatLon(currentSelection.x, currentSelection.y);
                let platlon = getLatLon(currentSelection.px, currentSelection.py);
                let rm = getMeters(latlon.lat, currentSelection.r);
                sel = Object.assign(sel, {
                    geo: true,
                    geoid: sel.id,
                    lat: latlon.lat,
                    lon: latlon.lon,
                    plat: platlon.lat,
                    plon: platlon.lon,
                    rm: rm
                });
            }

            selections.push(sel);
            currentSelection = null;

            addToTable(sel.id);
            addToSelectionCache(sel);
            if (settings.downloadImmediately) {
                cropAndDownload(sel.id);
            }

            renderWork();
            renderPrecisionHelper();
        }

        function cancelCurrentSelection() {
            currentSelection = null;
            renderWork();
            renderPrecisionHelper();
        }

        function scaleCurrentSelection(s) {
            if (!currentSelection) {
                return;
            }

            currentSelection.r += s;
            if (currentSelection.r < 0) {
                currentSelection.r = 0;
            }

            // this took some figuring out!
            let f = currentSelection.r / (currentSelection.r - s);
            currentSelection.px = currentSelection.x + (currentSelection.px - currentSelection.x) * f;
            currentSelection.py = currentSelection.y + (currentSelection.py - currentSelection.y) * f;

            renderWork();
            renderPrecisionHelper();
        }

        function moveCurrentSelection(x, y) {

            // if no current selection, clone the previous one next to itself in the direction of the move
            if (!currentSelection) {
                if (selections.length > 0) {
                    let sel = selections[selections.length-1];
                    let x0 = sel.x + Math.sign(x) * 2 * sel.r;
                    let y0 = sel.y + Math.sign(y) * 2 * sel.r;
                    cloneMostRecentSelectionAt(x0, y0);

                    renderWork();
                    renderPrecisionHelper();
                }
                return;
            }

            currentSelection.x += x;
            currentSelection.y += y;
            currentSelection.px += x;
            currentSelection.py += y;

            renderWork();
            renderPrecisionHelper();
        }

        function cloneMostRecentSelectionAt(x, y) {
            let previousSelection = selections[selections.length-1];
            currentSelection = {
                x: x,
                y: y,
                px: (previousSelection.px - previousSelection.x) + x,
                py: (previousSelection.py - previousSelection.y) + y,
                r: previousSelection.r
            };
        }

        function deleteMostRecentSelection() {
            let previousSelection = selections[selections.length-1];
            if (previousSelection) {
                deleteSelection(previousSelection.id);
            }
        }

        function getSelection(id) {
            return selections.find(s => s.id == id);
        }

        function highlightSelection(id) {
            highlightedSelectionId = id;
            renderWork();
        }

        function deleteSelection(id) {
            selections = selections.filter(s => s.id != id);
            removeFromSelectionCache(id);
            tableRowFor(id).remove();
            extractRelevantGeoSelectionsFromSelectionCache();
            renderWork();

            updateDownloadButtonAndTablePlaceholder();
        }

        function deleteAllSelections() {
            selections.forEach(s => {
                removeFromSelectionCache(s.id);
            });
            selections = [];
            clearTable();
            extractRelevantGeoSelectionsFromSelectionCache();
            renderWork();

            setStatus("Successfully deleted all current selections.")
        }


        /////////////////////////////////////
        // SELECTION MAKING & HIGHLIGHTING //
        /////////////////////////////////////

        let eucl = (x1, y1, x2, y2) => {
            let dx = Math.abs(x1 - x2);
            let dy = Math.abs(y1 - y2);
            return Math.sqrt(dx ** 2 + dy ** 2);
        };

        work.addEventListener('mousedown', e => {

            // only react if a normal click was performed
            if (e.button != 0) {
                return;
            }

            currentlySelecting = true;
            currentSelection = {
                x: logicalCanvasToImage(e.pageX),  // - left offset of #work wrt viewport if top left corner of canvas were not at (0,0)
                y: logicalCanvasToImage(e.pageY),  // analogous
                px: logicalCanvasToImage(e.pageX),
                py: logicalCanvasToImage(e.pageY),
                r: 0
            };
            renderWork();
            renderPrecisionHelper();
        });
        work.addEventListener('mousemove', e => {
            if (currentlySelecting) {
                let px = logicalCanvasToImage(e.pageX);  // see caveat above
                let py = logicalCanvasToImage(e.pageY);  // analogous

                let r = eucl(px, py, currentSelection.x, currentSelection.y);

                currentSelection.px = px;
                currentSelection.py = py;
                currentSelection.r = r;
                renderWork();
                renderPrecisionHelper();
            }
        });
        work.addEventListener('mouseup', e => {
            currentlySelecting = false;

            // on click, copy previous selection. currentSelection.r is always set here since it's been initialized in the mousedown e
            if (currentSelection.r == 0 && selections.length > 0) {
                let x = logicalCanvasToImage(e.pageX);  // see caveat above
                let y = logicalCanvasToImage(e.pageY);  // analogous

                cloneMostRecentSelectionAt(x, y);
            }
            renderWork();
            renderPrecisionHelper();
        });

        // circle hover => highlight
        work.addEventListener('mousemove', e => {

            if (!settings.showSelections || currentlySelecting) {

                // clear any previous highlights
                highlightedSelectionId = null;
                selections.forEach(s => tableRowFor(s.id).classList.remove("hover"));
                relevantGeoSelections.forEach(s => tableRowFor(s.id).classList.remove("hover"));
                return;
            }

            let x = logicalCanvasToImage(e.pageX);
            let y = logicalCanvasToImage(e.pageY);

            let candidates = selections.concat(relevantGeoSelections).filter(sel => {
                let r = eucl(x, y, sel.x, sel.y);
                return sel.r > r;
            });

            highlightedSelectionId = null;
            selections.forEach(s => tableRowFor(s.id).classList.remove("hover"));
            relevantGeoSelections.forEach(s => tableRowFor(s.id).classList.remove("hover"));

            if (candidates.length > 0) {
                let rMin = 999999999;
                let id = -1;
                candidates.forEach(sel => {
                    let r = eucl(x, y, sel.x, sel.y);
                    if (r < rMin) {
                        rMin = r;
                        id = sel.id;
                    }
                });

                tableRowFor(id).classList.add("hover");
                //tableRowFor(id).scrollIntoView();  // this would be neat if it was a no-op when the row is already in view
                highlightSelection(id);
            } else {
                highlightSelection(null);
            }
        });


        //////////////////////
        // SELECTIONS TABLE //
        //////////////////////

        function addToTable(id) {
            document.querySelector(".selections-table-container").classList.remove("hidden");

            let table = document.getElementById("selections-table-body");
            let sel = getSelection(id);

            let lat = "";
            let lon = "";
            let rm = "";
            if (sel.geo) {
                lat = `<span>${(sel.lat + "").toString().substring(0,8)}°</span>`;
                lon = `<span>${(sel.lon + "").substring(0,8)}°</span>`;
                rm = `<span>${parseInt(sel.rm)}m</span>`;
            }

            let cells = `
                <td>${parseInt(sel.x)}<u>px</u> ${lon}</td>
                <td>${parseInt(sel.y)}<u>px</u> ${lat}</td>
                <td>${parseInt(sel.r)}<u>px</u> ${rm}</td>
                <td>
                    <button onclick="cropAndDownload(${id})">
                        <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M0,-10 L0,10 M-10,0 L0,10 L10,0"></path></svg>
                    </button>
                    <button onclick="deleteSelection(${id})" class="delete">
                        <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M-9,-9 L9,9 M-9,9 L9,-9"></path></svg>
                    </button>
                </td>
                `;

            let tr = document.createElement("tr");
            tr.id = id;
            tr.setAttribute("onmouseover", "highlightSelection(" + id + ")");
            tr.setAttribute("onmouseout", "highlightSelection(null)");
            tr.innerHTML = cells;

            table.insertBefore(tr, table.firstChild);

            updateDownloadButtonAndTablePlaceholder();
        }

        function renderRelevantGeoSelectionsTable() {
            if (relevantGeoSelections.length > 0) {
                document.querySelector(".selections-table-container").classList.remove("hidden");
            }

            let table = document.getElementById("selections-table-foot");
            table.innerHTML = "";

            relevantGeoSelections.forEach(sel => {
                let lat = `<span>${(sel.lat + "").toString().substring(0,8)}°</span>`;
                let lon = `<span>${(sel.lon + "").substring(0,8)}°</span>`;
                let rm = `<span>${parseInt(sel.rm)}m</span>`;

                let cells = `
                    <td>${lon}</td>
                    <td>${lat}</td>
                    <td>${rm}</td>
                    <td>
                        <button onclick="acceptGeoSelection(${sel.id})">
                            <svg viewBox="-11 -11 22 22" style="stroke: currentColor; stroke-width: 2.5; fill: none; height: 0.8em;"><path d="M-10,1 L0,9 L9,-9"></path></svg>
                        </button>
                    </td>
                    `;

                let tr = document.createElement("tr");
                tr.id = sel.id;
                tr.setAttribute("onmouseover", "highlightSelection(" + sel.id + ")");
                tr.setAttribute("onmouseout", "highlightSelection(null)");
                tr.innerHTML = cells;

                table.insertBefore(tr, table.firstChild);

                updateDownloadButtonAndTablePlaceholder();
            });
        }

        function clearTable() {
            let table = document.getElementById("selections-table-body");
            table.innerHTML = "";

            updateDownloadButtonAndTablePlaceholder();
        }

        function tableRowFor(id) {
            return document.getElementById(id);
        }

        function updateDownloadButtonAndTablePlaceholder() {
            document.getElementById("selection-count").innerText = selections.length + " selection" + ((selections.length != 1) ? "s" : "");

            if (selections.length < 2) {
                document.querySelector(".download-all").style.display = "none";
            } else {
                document.querySelector(".download-all").style.display = "flex";
            }

            if (selections.length == 0 && relevantGeoSelections.length == 0) {
                document.getElementById("no-selections").style.display = "table-row";
            } else {
                document.getElementById("no-selections").style.display = "none";
            }
        }

        function acceptGeoSelection(id) {
            let sel = getRelevantGeoSelection(id);

            sel.geoid = sel.id;
            sel.id = Date.now();
            sel.fileid = imageInfo.fileid;

            selections.push(sel);
            addToTable(sel.id);
            addToSelectionCache(sel);
            extractRelevantGeoSelectionsFromSelectionCache();

            renderWork();
        }


        /////////////////////////
        // CROPPING & DOWNLOAD //
        /////////////////////////

        function assembleFilename(id) {
            let sel = getSelection(id);

            // super basic string variable replacement, via https://stackoverflow.com/a/1408373
            let supplant = (s, o) => {
                return s.replace(/{([^{}]*)}/g,
                    function (a, b) {
                        var r = o[b];
                        return typeof r === 'string' || typeof r === 'number' ? r : a;
                    }
                );
            };

            let filenameVariables = {
                file: imageInfo.name,
                id: sel.id,
                date: (new Date()).toISOString().replace(/\:/g, "."),
                rand: (Math.random() + "").slice(2,12),
                x: parseInt(sel.x),
                y: parseInt(sel.y),
                r: parseInt(sel.r),
            }

            if (sel.geo) {
                filenameVariables = Object.assign(filenameVariables, {
                    georect: `sw${geoRect.sw.lat},${geoRect.sw.lon}ne${geoRect.ne.lat},${geoRect.ne.lon}`,
                    lat: sel.lat,
                    lon: sel.lon,
                    rm: sel.rm
                });
            }

            let defaultFilenameTemplate = supplant("cropcircles-x{x}y{y}r{r}", filenameVariables);
            if (geoRect) {
                defaultFilenameTemplate = supplant("cropcircles-{lat},{lon},{rm}m-x{x}y{y}r{r}", filenameVariables);
            }

            filenameVariables = Object.assign(filenameVariables, {
                default: defaultFilenameTemplate
            });

            let filename = supplant(settings.filenameTemplate, filenameVariables);

            if (filename == "") {  // this means the template was not set
                filename = supplant("{default}", filenameVariables);
            }

            return filename;
        }

        function cropImageToSelection(id) {
            let sel = getSelection(id);

            let x = sel.x;
            let y = sel.y;
            let r = sel.r;

            let width = Math.ceil(r * 2);
            let height = Math.ceil(r * 2);
            if (!settings.transparentBackground) {
                width += 2 * r * settings.horizontalMargin;
                height += 2 * r * settings.verticalMargin;
            }

            let croppedImage = document.getElementById("cropped-image");

            croppedImage.setAttribute("width", width);
            croppedImage.setAttribute("height", height);

            let cic = croppedImage.getContext("2d");
            cic.clearRect(0, 0, width, height);

            if (!settings.transparentBackground) {
                cic.drawImage(image, x - r - r * settings.horizontalMargin, y - r - r * settings.verticalMargin, width, height, 0, 0, width, height);
            }
            else {
                cic.save();
                cic.beginPath();
                cic.arc(r, r, r, 0, 2 * Math.PI);
                cic.closePath();
                cic.clip();
                cic.drawImage(image, x - r, y - r, width, height, 0, 0, width, height);
                cic.restore();
            }

            return croppedImage;
        }

        function cropAndPrepareBlob(id, blobAction) {
            let croppedImage = cropImageToSelection(id);
            let filename = assembleFilename(id);

            let imageType = "image/png";
            let imageQuality = 1;
            let imageExtension = ".png";
            if (!settings.transparentBackground) {
                imageType = "image/jpeg";
                imageExtension = ".jpg";
            }

            croppedImage.toBlob(blob => {
                blobAction(filename + imageExtension, blob);
            }, imageType, imageQuality);
        }

        function cropAndDownload(id) {
            setStatus("Cropping image and preparing for download…", true);
            cropAndPrepareBlob(id, (filename, blob) => {
                let url = URL.createObjectURL(blob);
                download(url, filename);
                URL.revokeObjectURL(url);

                clearStatus();
            });
        }

        async function downloadAll() {
            setStatus("Cropping images and downloading them sequentially – this might take a while…", true);

            // this works brilliantly in chrome and firefox, but safari only ever downloads the last image – even with trying various delays, i couldn't get it to reliably download all
            selections.forEach(sel => {
                cropAndPrepareBlob(sel.id, (filename, blob) => {
                    let url = URL.createObjectURL(blob);
                    download(url, filename);
                    URL.revokeObjectURL(url);
                });
            });
            clearStatus();
        }

        async function downloadZip() {

            // pieced together from jszip docs and fiddling around, genuinely no clue how it works or if it could be done better
            let filename = "cropcircles-" + imageInfo.name.replace(/\./g, "-") + ".zip";
            setStatus("Generating ZIP – this might take a bit as there's " + selections.length + " crops to be performed…", true);

            let zip = new JSZip();

            let promises = selections.map(sel => {
                return new Promise(function (resolve, reject) {
                    cropAndPrepareBlob(sel.id, (filename, blob) => {
                        resolve([filename, blob]);
                    });
                });
            });

            let resolveds = await Promise.all(promises);
            resolveds.forEach(content => {
                zip.file(content[0], content[1]);
            });

            zip.generateAsync({type: "blob"})
                .then(function(blob) {
                    let url = URL.createObjectURL(blob);
                    download(url, filename);
                    URL.revokeObjectURL(url);

                    clearStatus();
                });
        }


        //////////////////////////
        // KEYBOARD INTERACTION //
        //////////////////////////

        window.addEventListener("keydown", function (e) {

            // disable this if the focus is on one of the inputs in the sidebar – interferes with filename input, possibly others too!
            // or if any modifiers are pressed – the user is trying to interact with their browser, not with me!
            if (e.target.tagName == "INPUT" || e.ctrlKey || e.altKey || e.metaKey) {
                return;
            }

            let factor = 1;
            let larger = 20;
            if (e.shiftKey) {
                factor = larger;
            }

            console.log(e.key, e.code);

            switch (e.key) {
                case "Enter":
                    acceptCurrentSelection();
                    break;
                case "Escape":
                    cancelCurrentSelection();
                    break;
                case "Backspace":
                    deleteMostRecentSelection();
                    break;

                case "ArrowUp":
                    moveCurrentSelection(0, -factor);
                    break;
                case "ArrowDown":
                    moveCurrentSelection(0, factor);
                    break;
                case "ArrowLeft":
                    moveCurrentSelection(-factor, 0);
                    break;
                case "ArrowRight":
                    moveCurrentSelection(factor, 0);
                    break;

                case "+":
                    scaleCurrentSelection(factor);
                    break;
                case "-":
                    scaleCurrentSelection(-factor);
                    break;

                case "*":  // "shift +" on the German keyboard layout i use
                    scaleCurrentSelection(larger);
                    break;
                case "_":  // "shift -" on the German keyboard layout i use
                    scaleCurrentSelection(-larger);
                    break;

                default:

                    // handle wasd based on key codes, i.e. positions instead
                    switch (e.code) {
                        case "KeyW":
                            moveCurrentSelection(0, -factor);
                            break;
                        case "KeyS":
                            moveCurrentSelection(0, factor);
                            break;
                        case "KeyA":
                            moveCurrentSelection(-factor, 0);
                            break;
                        case "KeyD":
                            moveCurrentSelection(factor, 0);
                            break;
                        case "KeyP":
                            scaleCurrentSelection(factor);
                            break;
                        case "KeyO":
                            scaleCurrentSelection(-factor);
                            break;
                        default:
                            return;  // quit when we don't want to handle the key event
                    }
              }

            // cancel the default action to avoid it being handled twice
            e.preventDefault();
        }, true);


        /////////////////////
        // WINDOW RESIZING //
        /////////////////////

        window.addEventListener('resize', () => {
            let h = window.innerHeight
            let w = document.querySelector("main").offsetWidth;

            work.style.width = w + "px";
            work.style.height = h + "px";
            setupWork();

            drawNewImage();  // this sets scale
            renderWork();
        });


        //////////////
        // SETTINGS //
        //////////////

        let settings = {
            showSelections: null,
            precisionHelperZoom: null,
            downloadImmediately: null,
            filenameTemplate: null,
            transparentBackground: null,
            verticalMargin: null,
            horizontalMargin: null
        }

        let showSelectionsCheckbox = document.querySelector(".show-selections-checkbox");
        let precisionHelperZoomSlider = document.querySelector(".precision-helper-zoom-slider");
        let downloadImmediatelyCheckbox = document.querySelector(".download-immediately-checkbox");
        let filenameTemplateField = document.querySelector(".filename-template-field");

        let transparentBackgroundCheckbox = document.querySelector(".transparent-background-checkbox");
        let marginSettings = document.querySelector(".margin-settings");
        let verticalMarginSlider = document.querySelector(".vertical-margin-slider");
        let horizontalMarginSlider = document.querySelector(".horizontal-margin-slider");

        function initSettingsFromLocalStorage() {
            let s = window.localStorage.getItem("cropcircles-settings");
            try {
                if (s == null) {
                    throw '';
                }
                settings = JSON.parse(s);
            } catch (e) {
                resetSettingsToDefaults(true);
            }
        }

        function applySettings() {

            // adjust dom to match settings
            showSelectionsCheckbox.checked = settings.showSelections;
            updateShowSelections(showSelectionsCheckbox);

            precisionHelperZoomSlider.value = settings.precisionHelperZoom;
            adjustPrecisionHelperZoom(precisionHelperZoomSlider);

            downloadImmediatelyCheckbox.checked = settings.downloadImmediately;
            updateDownloadImmediately(downloadImmediatelyCheckbox);

            filenameTemplateField.value = settings.filenameTemplate;
            updateFilenameTemplate(filenameTemplateField);

            transparentBackgroundCheckbox.checked = settings.transparentBackground;
            updateTransparentBackground(transparentBackgroundCheckbox);

            verticalMarginSlider.value = settings.verticalMargin;
            adjustVerticalMargin(verticalMarginSlider);

            horizontalMarginSlider.value = settings.horizontalMargin;
            adjustHorizontalMargin(horizontalMarginSlider);
        }

        function setupSettings() {
            initSettingsFromLocalStorage();
            applySettings();
        }

        function writeSettingsToLocalStorage() {
            window.localStorage.setItem("cropcircles-settings", JSON.stringify(settings));
        }

        function downloadSettings() {
            let url = "data:application/json;charset=utf-8," + encodeURIComponent(JSON.stringify({settings: settings}));
            download(url, "cropcircles-settings.json");
        }

        let uploadSettingsFilePicker = document.getElementById("upload-settings");

        function restoreSettings() {
            uploadSettingsFilePicker.click();
        }

        // used for both settings and selection cache
        function jsonFilePickerChanged(e, callback) {
            let files = e.target.files;
            let file = files[0];

            let filename = file.name;

            let reader = new FileReader();
            reader.onload = e => {
                let s = e.target.result;

                let json;
                try {
                    json = JSON.parse(s);
                } catch (e) {
                    showError("The file \"" + file.name + "\" doesn't seem to contain a valid JSON value.");
                }

                // call callback
                callback(filename, json);

                // forget about the file, allowing the event handler to fire again if the user uploads the same file again
                uploadSettingsFilePicker.value = "";
            };
            reader.readAsText(file);
        }

        uploadSettingsFilePicker.addEventListener('change', e => {
            jsonFilePickerChanged(e, (filename, rawSettings) => {
                if (!("settings" in rawSettings)) {
                    showError("The file \"" + filename + "\" doesn't contain a \"settings\" attribute. Did you upload a selection cache backup by accident?");
                    return;
                }
                settings = rawSettings.settings;
                applySettings();
                setStatus("Successfully restored settings from \"" + filename + "\".");
            });
        });

        function resetSettingsToDefaults(quietly = false) {
            showSelectionsCheckbox.checked = showSelectionsCheckbox.getAttribute("data-default") == "yes";
            updateShowSelections(showSelectionsCheckbox);
            precisionHelperZoomSlider.value = precisionHelperZoomSlider.getAttribute("data-default");
            adjustPrecisionHelperZoom(precisionHelperZoomSlider);
            downloadImmediatelyCheckbox.checked = downloadImmediatelyCheckbox.getAttribute("data-default") == "yes";
            updateDownloadImmediately(downloadImmediatelyCheckbox);
            filenameTemplateField.value = filenameTemplateField.getAttribute("data-default");
            updateFilenameTemplate(filenameTemplateField);

            transparentBackgroundCheckbox.checked = transparentBackgroundCheckbox.getAttribute("data-default") == "yes";
            updateTransparentBackground(transparentBackgroundCheckbox);
            verticalMarginSlider.value = verticalMarginSlider.getAttribute("data-default");
            adjustVerticalMargin(verticalMarginSlider);
            horizontalMarginSlider.value = horizontalMarginSlider.getAttribute("data-default");
            adjustHorizontalMargin(horizontalMarginSlider);

            if (!quietly) {
                setStatus("Successfully reset the settings to their default values.");
            }
        }

        function updateShowSelections(checkbox) {
            settings.showSelections = !!checkbox.checked;
            writeSettingsToLocalStorage();
            renderWork();
        }

        function adjustPrecisionHelperZoom(slider) {
            settings.precisionHelperZoom = parseFloat(slider.value);
            precisionHelperZoomSlider.parentNode.querySelector("b").innerHTML = settings.precisionHelperZoom + "×";
            writeSettingsToLocalStorage();
            renderPrecisionHelper();
        }

        function updateDownloadImmediately(checkbox) {
            settings.downloadImmediately = !!checkbox.checked;
            writeSettingsToLocalStorage();
        }

        function updateFilenameTemplate(field) {
            settings.filenameTemplate = field.value;
            writeSettingsToLocalStorage();
        }

        function updateTransparentBackground(checkbox) {
            settings.transparentBackground = !!checkbox.checked;
            writeSettingsToLocalStorage();
            if (settings.transparentBackground) {
                marginSettings.classList.add("disabled");
                verticalMarginSlider.disabled = true;
                horizontalMarginSlider.disabled = true;
            } else {
                marginSettings.classList.remove("disabled");
                verticalMarginSlider.disabled = false;
                horizontalMarginSlider.disabled = false;
            }
            renderWork();
        }

        function computeAspectRatio() {
            let w = (2 * (settings.horizontalMargin + 1));
            let h = (2 * (settings.verticalMargin + 1));
            let aspectRatio = w / h;

            // some common values, could do this more nicely with a gcd algorithms, but meh
            if (aspectRatio == 16 / 9) {
                return "16:9";
            } else if (aspectRatio == 4 / 3) {
                return "4:3";
            } else if (aspectRatio == 3 / 2) {
                return "3:2";
            } else if (aspectRatio == 2 / 1) {
                return "2:1";
            }

            return (aspectRatio + "").substring(0, 4) + ":" + 1;
        }

        function adjustVerticalMargin(slider) {
            settings.verticalMargin = parseFloat(slider.value);
            verticalMarginSlider.parentNode.querySelector("b").innerHTML = settings.verticalMargin + "·<em>r</em>";
            document.querySelector(".aspect-ratio").innerText = computeAspectRatio();
            writeSettingsToLocalStorage();
            renderWork();
        }

        function adjustHorizontalMargin(slider) {
            settings.horizontalMargin = parseFloat(slider.value);
            horizontalMarginSlider.parentNode.querySelector("b").innerHTML = settings.horizontalMargin + "·<em>r</em>";
            document.querySelector(".aspect-ratio").innerText = computeAspectRatio();
            writeSettingsToLocalStorage();
            renderWork();
        }


        /////////////////////
        // SELECTION CACHE //
        /////////////////////

        function setupSelectionCache() {
            let s = window.localStorage.getItem("cropcircles-selectioncache");
            try {
                if (s == null) {
                    throw '';
                }
                selectionCache = JSON.parse(s);
            } catch (e) {
                purgeSelectionCache(true);
            }
        }

        function writeSelectionCacheToLocalStorage() {
            window.localStorage.setItem("cropcircles-selectioncache", JSON.stringify(selectionCache));
        }

        function downloadSelectionCache() {
            let url = "data:application/json;charset=utf-8," + encodeURIComponent(JSON.stringify({selectioncache: selectionCache}));
            download(url, "cropcircles-selectioncache.json");
        }

        let uploadSelectionCacheFilePicker = document.getElementById("upload-selectioncache");

        function restoreSelectionCache() {
            uploadSelectionCacheFilePicker.click();
        }

        uploadSelectionCacheFilePicker.addEventListener('change', e => {
            jsonFilePickerChanged(e, (filename, rawSelectionCache) => {
                if (!("selectioncache" in rawSelectionCache)) {
                    showError("The file \"" + filename + "\" doesn't contain a \"selectioncache\" attribute. Did you upload a settings backup by accident?");
                    return;
                }
                let tmpSelectionCache = rawSelectionCache.selectioncache;

                // merge with current selection cache: only add those that are not already in the selection cache
                tmpSelectionCache = tmpSelectionCache.filter(s => {
                    return null == selectionCache.find(t => s.id == t.id);
                });

                selectionCache = tmpSelectionCache;
                writeSelectionCacheToLocalStorage();
                recoverSelectionsFromSelectionCache();
                extractRelevantGeoSelectionsFromSelectionCache();

                setStatus("Successfully restored selection cache from \"" + filename + "\".");
            });
        });

        function recoverSelectionsFromSelectionCache() {
            let cachedSelections = selectionCache.filter(sel => {

                // if already in list of current selections (which can happen during restores or resets), no need to add it
                if (getSelection(sel.id)) {
                    return false;
                }

                // if from the same image, bullseye
                if (sel.fileid == imageInfo.fileid) {
                    return true;
                }

                return false;
            });

            // could explicitly order by id (descending) here, but the order is actually guaranteed anyway because the selection cache is a list that's originally been populated in order of id
            cachedSelections.forEach(sel => {
                selections.push(sel);
                addToTable(sel.id);
            });

            renderWork();
        }

        function extractRelevantGeoSelectionsFromSelectionCache() {
            if (!geoRect) {
                return;
            }

            relevantGeoSelections = selectionCache.filter(sel => {

                // if already in list of current selections (which can happen during restores or resets) or from the same file, no need to add it
                if (getSelection(sel.geoid) || selections.find(s => s.geoid == sel.id) || sel.fileid == imageInfo.fileid) {
                    return false;
                }

                // if within the current georect, yeah!
                if (sel.geo && geoRect.sw.lat <= sel.lat && sel.lat <= geoRect.ne.lat && geoRect.sw.lon <= sel.lon && sel.lon <= geoRect.ne.lon) {
                    return true;
                }

                return false;
            });

            // if the same selelection from image x has also been accepted into image y, image z will see it twice. thus, need to filter here: remove duplicates wrt selection.geoid!
            // based on https://stackoverflow.com/a/9229821
            let seen = [];
            relevantGeoSelections = relevantGeoSelections.filter(sel => {
                if (seen.includes(sel.geoid)) {
                    return false;
                }
                seen.push(sel.geoid);
                return true;
            });

            relevantGeoSelections = relevantGeoSelections.map(sel => {
                let xy = getXY(sel.lat, sel.lon);
                let pxy = getXY(sel.plat, sel.plon);
                let r = getPixels(sel.plat, sel.rm);

                // clone to avoid modifying the original, which "belongs" to another image
                sel = JSON.parse(JSON.stringify(sel));

                sel.x = xy.x;
                sel.y = xy.y;
                sel.px = pxy.x;
                sel.py = pxy.y;
                sel.r = r;

                return sel;
            });

            // could explicitly order by id (descending) here, but the order is actually guaranteed anyway because the selection cache is a list that's originally been populated in order of id
            renderRelevantGeoSelectionsTable();
            renderWork();
        }

        // reset to only include the current selections
        function purgeSelectionCache(quietly = false) {
            selectionCache = selections;
            writeSelectionCacheToLocalStorage();

            // hide any now-nonexistant geo selections
            extractRelevantGeoSelectionsFromSelectionCache();
            renderWork();

            if (!quietly) {
                setStatus("Successfully purged the selection cache – only your current selections remain.");
            }
        }

        function getRelevantGeoSelection(id) {
            return relevantGeoSelections.find(s => s.id == id);
        }

        function addToSelectionCache(sel) {
            selectionCache.push(sel);
            writeSelectionCacheToLocalStorage();
        }

        function removeFromSelectionCache(id) {
            selectionCache = selectionCache.filter(s => s.id != id);
            writeSelectionCacheToLocalStorage();
        }


        //////////////////
        // USER'S GUIDE //
        //////////////////

        let usersGuide = document.querySelector(".users-guide");

        function setupUsersGuide() {
            let usersGuideSeparators = [
                "assets/separator-cropcircles-42.3111113461317,-113.82287051002871,393.53231582108054m-x15141y7401r891.png",
                "assets/separator-cropcircles-42.29690988557858,-113.85740865866183,381.7277290054806m-x8703y10982r864.png",
                "assets/separator-cropcircles-42.31146200590124,-113.87692738663816,381.00746284369m-x5065y7313r862.png",
                "assets/separator-cropcircles-42.31896473064041,-113.89633345872075,363.90613738248487m-x1447y5421r824.png",
                "assets/separator-cropcircles-42.33294035409268,-113.818144634703,368.1942960451643m-x16022y1899r834.png",
                "assets/separator-cropcircles-42.33317724690913,-113.85772768051488,381.4103398705216m-x8644y1839r863.png"
                ];

            // choose three for each separator
            usersGuide.querySelectorAll(".separator").forEach(e => {

                // shuffle
                for (let i = usersGuideSeparators.length - 1; i > 0; i--) {
                    let j = Math.floor(Math.random() * (i + 1));
                    [usersGuideSeparators[i], usersGuideSeparators[j]] = [usersGuideSeparators[j], usersGuideSeparators[i]];
                }

                // choose
                usersGuideSeparators.slice(0, 3).forEach(url => {
                    let img = document.createElement("img");
                    img.src = url;
                    e.appendChild(img);
                });
            });
        }

        function showUsersGuide(section) {
            usersGuide.style.display = "block";
            if (section) {
                document.getElementById(section).scrollIntoView();
            }
        }

        function hideUsersGuide() {
            usersGuide.style.display = "none";
            usersGuide.querySelectorAll("video").forEach(e => e.pause());
        }


        /////////////////////
        // STATUS MESSAGES //
        /////////////////////

        let status = document.querySelector(".status");
        let statusTimeout = null;

        // helper function for displaying status messages
        function setStatus(message, persist) {
            status.innerHTML = message;
            status.classList.remove("hidden");
            if (!persist) {

                // clear any previous timeout first – it would cause the new status to disappear earlier than intended
                if (statusTimeout) {
                    clearTimeout(statusTimeout);
                }
                statusTimeout = setTimeout(clearStatus, 2000);
            }
        }

        // helper function for hiding the current status message
        function clearStatus() {
            status.classList.add("hidden");
        }


        ////////////////////
        // ERROR MESSAGES //
        ////////////////////

        let error = document.querySelector(".error");

        function showError(message, label = true) {
            error.classList.remove("hidden");
            let errorMessage = document.querySelector(".error-message");
            if (label) {
                message = "<strong>Error:</strong> " + message;
            }
            errorMessage.innerHTML = message;
        }

        function dismissError() {
            error.classList.add("hidden");
        }


        //////////////////
        // MOBILE ALERT //
        //////////////////

        let mobileAlertAlreadyShown = false;

        // as per https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent and https://stackoverflow.com/a/24600597, throw an alert if the user agent contains "Mobi"
        if (/Mobi/.test(navigator.userAgent)) {
            showError(`Hi there! It looks like <em>you're using a mobile device</em>. Sadly, this app was built with mouse and keyboard interaction in mind – please move over to an old-fashioned computer and proceed there.`, false);
            mobileAlertAlreadyShown = true;
        }

        // also throw alert if the screen is touched
        document.addEventListener("touchstart", () => {
            if (!mobileAlertAlreadyShown) {
                showError(`Hi there! It looks like <em>you've just tapped the screen of your presumably-mobile device</em>. Sadly, this app was built with mouse and keyboard interaction in mind – please move over to an old-fashioned computer and proceed there.`, false);
                mobileAlertAlreadyShown = true;
            }
        });


        ////////////////////////////////////
        // IT'S LIGHTS OUT AND AWAY WE GO //
        ////////////////////////////////////

        dpr = 1;
        if (window.devicePixelRatio) {
            dpr = window.devicePixelRatio;
        }

        setupPrecisionHelper();
        setupWork();

        setupSettings();
        setupSelectionCache();

        setupUsersGuide();
    </script>
</body>
</html>
