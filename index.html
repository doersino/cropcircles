<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" lang="en">
    <title>Crop Circles</title>
    <link rel="stylesheet" href="libs/ttf-iosevka-aile-3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        :root {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --users-guide-background-color: #111;

            --status-background-color: #444;

            --precision-helper-background-color: #000;

            --main-background-color: #131313;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --dropper-background-color: #555;
            --dropper-color: #aaa;

            --current-selection-stroke: #fff;
            --old-selections-stroke: rgba(255,255,255,0.5);
            --old-selections-fill: rgba(255,255,255,0.2);
            --precision-helper-dividers-stroke: #555;
        }
        html {
            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem
        }
        button, label, input[type="text"] {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem
        }
        button:hover, label:hover, input[type="text"]:hover {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            font-weight: normal;
            float: right;
            color: var(--input-current-value-color);
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        a.reset {
            display: inline-block;
            text-transform: uppercase;
            text-decoration: none !important;
            font-size: 0.6em !important;
            letter-spacing: 1px;
        }

        /* USER'S GUIDE */
        .users-guide {
            position: fixed;
            top: 0;
            left: 0;
            height: 90vh;
            overflow: scroll;
            max-width: 40em;
            margin: 5vh 0 0 5vh;
            padding: 1em 4em 2em 2em;
            z-index: 10;
            background-color: var(--users-guide-background-color);
            box-shadow: 0.5em 0.5em 4em var(--users-guide-background-color);
            display: none;
        }
        .close {
            display: block;
            text-decoration: none;
            font-size: 3em;
            position: fixed;
            margin: -1rem 0 0 35rem;
            font-weight: 200;
        }
        h2 {
            font-weight: 300;
            text-transform: uppercase;
            font-size: 1.5em;
            margin-top: 1.5em;
        }

        /* STATUS */
        footer {
            position: fixed;
            right: 0;
            bottom: var(--sidebar-width);
            width: var(--sidebar-width);
            background-color: var(--status-background-color);
            padding: 1em;
            font-size: 0.8em;
            pointer-events: none;
            opacity: 1;
        }
        footer.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background-color: var(--main-background-color);
        }
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
            width: calc(100vw - var(--sidebar-width));
            position: absolute;
        }
        .dropper-text {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 1em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 40%;
            margin: auto;
            margin-top: 20vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }
        #dropped-image, #cropped-image {
            display: none;
        }
        #base-image {
            position: absolute;
        }
        #work {
            position: absolute;
            display: block;
            height: 100vh;
            width: calc(100vw - var(--sidebar-width));
            cursor: crosshair;
        }

        /* TODO clean up position absolute and fixed */

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
            <svg viewBox="0 0 250 250" aria-hidden="true">
                <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
                <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
                <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
            </svg>
        </a>
        <h1><em>Crop</em> Circles</h1>
        <p>A tool for cropping circular <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery.</p>
        <span><strong>Usage:</strong> Provide an image, click and drag from a center point to make a selection, refine it with <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> <kbd>+</kbd> <kbd>-</kbd>, then press <kbd>enter</kbd> to download the cropped result. <a href="javascript:showUsersGuide();">Learn more…</a></span>

        <hr>

        <label><input type="checkbox" class="show-old-selections-checkbox" data-default="yes" onclick="updateShowOldSelections(this);" checked> show old selections</label>
        <span>Show previously selected circles to help you keep track of what you've already done.</span>

        <label>
            <input type="range" min="0.1" max="2.0" step="0.1" value="1.0" data-default="1.0" class="precision-helper-zoom-slider" oninput="adjustPrecisionHelperZoom(this.value)">
            <br>
            <b>1.0×</b>
            precision helper zoom
        </label>
        <span>Adjusts the zoom level of the thumbnails shown in the precision helper below.</span>

        <label><input type="checkbox" class="include-surroundings-checkbox" data-default="no" onclick="updateIncludeSurroundings(this);"> include surroundings</label>
        <span>Instead of a transparent background, include the surroundings of the selection in the corners. Essentially turns the circular crop area into a rectangular crop area. You can widen the scope of the surroundings with the options below. TODO also: JPEG</span>

        TODO disable the settings below if "include surroundings" not true

        <label>
            <input type="range" min="0.0" max="2.0" step="0.1" value="0.0" data-default="0.0" class="vertical-surroundings-range-slider" oninput="adjustVerticalSurroundingsRange(this.value)">
            <br>
            <b>0<em style="text-transform: lowercase;">r</em></b>
            vertical surroundings range TODO rename
        </label>
        <span>If set to a value ≠ 0, TODO more</span>

        TODO same for horizontal

        <!--<button onclick="copySource(this);">copy source<b></b></button>
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <input type="text" placeholder="Location">
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <button onclick="downloadSVG();">download svg<b></b></button>
        <span>Handy for inserting your diagram into a non-Markdeep document. <em>Includes the source in a &lt;metadata&gt; tag.</em></span>

        <hr>

        <label><input type="checkbox" onclick="toggleDarkMode(this);" data-default="light" class="dark-mode-checkbox"> dark mode</label>

        <label>
            <input type="range" min="0.5" max="3.0" step="0.01" value="1.0" data-default="1.0" class="zoom-level-slider" oninput="adjustZoomLevel(this.value)">
            <br>zoom level <b>100%</b>
        </label>
        <span>Scales both source and preview.</span>

        <label>
            <input type="range" min="1.00" max="1.50" step="0.01" value="1.25" data-default="1.25" class="line-height-slider" oninput="adjustLineHeight(this.value)">
            <br>line height <b>1.25em</b>
        </label>
        <label>
            <input type="range" min="-0.30" max="0.45" step="0.01" value="0.15" data-default="0.15" class="letter-spacing-slider" oninput="adjustLetterSpacing(this.value)">
            <br>letter spacing <b>0.15px</b>
        </label>
        <span>Both of the above might need adjusting depending on your zoom level, browser and installed fonts.</span>-->

        <hr>

        <p><span><em>These settings are continually written to local storage and will be restored when you close and reopen this page.</em></span></p>
        <a class="reset" href="javascript:resetSettings();">reset settings</a>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>
    <footer class="hidden"></footer>
    <main>
        <img id="base-image">
        <canvas id="work"></canvas>
        <div class="dropper">
            <div class="dropper-text">
                Drop image here
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
    </main>
    <img id="dropped-image">
    <canvas id="cropped-image"></canvas>

    <section class="users-guide">
        <a href="javascript:hideUsersGuide();" class="close">×</a>
        <p><a href="https://github.com/doersino/cropcircles">This</a> is a tool originally designed for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery such as the kind generated by <a href="https://github.com/doersino/aerialbot">ærialbot</a>. <em>(But nothing's keeping you from using it to crop circles from imagery-in-a–more–general–sense.)</em></p>

        <h2>Basic Usage</h2>
        <p>1. Drop an image into the main area.</p>
        <p>2. Click and drag from a center point to make a circular selection.
        <p>3. Keeping an eye on the precision helper in the bottom right, adjust the selection with the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd> (or with <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd>); you can increase or decrease the size of your selection with <kbd>+</kbd> <kbd>-</kbd> (or <kbd>P</kbd> <kbd>O</kbd>. Press <kbd>shift</kbd> to adjust in 20× larger increments.</p>
        <p>4. When satisfied, press <kbd>enter</kbd> to accept the selected circle – it will then download as a PNG image, tightly cropped around the x and y bounds of the circle, with transparent corners. (If you wish to cancel the current selection, press <kbd>esc</kbd>.)</p>
        <p>5. Repeat steps 2 through 4 for as many circles as you'd like to select.</p>

        <h2>Configuration</h2>

        <p>TODO</p>

        <h2>Geo-Awareness</h2>
        <p>If the dropped file's filename if of the form TODO with latlon, the cropped circles will be named based on their center point's latitude, longitude and circle radius (that one in meters). This assumes that the aerial imagery you've uploaded is laid out based on a TODO what kinda projection?, which probably isn't true (it's the Web Mercator projection TODO if aerialbot) – but on small scales (sub-10km), it's accurate enough (no less accurate than the "registration" of the imagery, i bet).</p>

        <hr>

        <h2>Privacy Policy</h2>
        <p>There isn't any server communication beyond the initial page load, so you should be safe. No analytics or trackers either. This tool is hosted on GitHub Pages, so I don't even have access to web server logs (but presumably, GitHub does).</p>
        <p>But don't take my word for it: Just download this tool (TODO link), disconnect your device from the internet, open the tool in an incognito window, do your work, close the window, delete your local copy of the tool, then enable wifi again.</p>

        <h2>Credit</h2>
        <p>TODO font, TODO inspo project, TODO mddb</p>
    </section>

    <script src="https://code.jquery.com/jquery-latest.js" crossorigin="anonymous"></script>
    <script>
        // TODO now, implement:
        // * maybe a list in the sidebar, with a re-download possibility?
        // * think of additional, more useful settings
        // * maybe get latlon from filename somehow? would need nw and se in there. then also have (linearly interpolated, no need to be fancy at these scales) latlon in output filename.
        // * on click, insert a circle the size of the previous circle? that could get around mi/km selection necessity
        // * similarly, on move or resize immediately after accepting a circle (i.e. before starting to draw a new one), make a copy of the just-accepted one and proceed with that
        // * maybe support for browser resizing, but that's a buncha work for zero benefit in practice. otherwise, show a warning on resize?
        // * make main drag area also pop up a file selector when clicked: https://stackoverflow.com/a/28075416

        // shower thoughts:
        // TODO option: include surroundings. (replaces backgroudn drowpdown) slider: horiz distance to incldue in *r, vertical distance to include in *r => include background, emit jpg, display box preview during circle selecting <------ make this fully work!
        // TODO option: don't immediately downlaod upon selction acceptance
        // TODO clicking on prev circles redownloads them with current settings
        // TODO keep hash of image, along with circles, in local storage. provide means of backing local storage up (button!) and restoring it (mini drag area in sidebar? or just file selection button. or both!). (also wiping, i guess). => then, if user drags in a previously-dragged image, the previously-marked circles will show up. might then need a way of removing circles? hover and backspace? maybe highlight circles on hover

        /////////////
        // GLOBALS //
        /////////////

        let dpr = 1;
        let scale = null;

        let precisionHelper = null;
        let work = null;

        let currentlySelectingCircle = false;
        let currentCircle = null;

        let circles = [];


        /////////////
        // HELPERS //
        /////////////

        // via https://gist.github.com/luciopaiva/01bda0d4311ccaecea0478ad2fd03108
        function readCssVar(name) {
            name = name.startsWith("--") ? name : "--" + name;
            return window.getComputedStyle(document.documentElement).getPropertyValue(name);
        }

        function logicalCanvasToImage(n) {  // for mouse tracking
            return n * dpr / scale;
        }
        function imageToLogicalCanvas(n) {  // for image sizing
            return scale * n / dpr;
        }
        function imageToPhysicalCanvas(n) {  // for selection drawing
            return n * scale;
        }
        function logicalCanvastoPhysicalCanvas(n) {  // primarily for line strength scaling
            return n * dpr;
        }

        function setupCanvas(elem) {

            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels (larger on retina devices)
            let w = elem.offsetWidth;
            let h = elem.offsetHeight;
            elem.style.width = w + "px";
            elem.style.height = h + "px";

            let W = w * dpr;
            let H = h * dpr;
            elem.setAttribute("width", W);
            elem.setAttribute("height", H);

            return {
                elem: elem,
                ctx: elem.getContext("2d"),
                w: w,
                h: h,
                W: W,
                H: H
            }
        }

        //////////////////
        // CANVAS SETUP //
        //////////////////

        function setupPrecisionHelper() {
            let prec = document.getElementById("prec");
            precisionHelper = setupCanvas(prec);
            renderPrecisionHelper();
        }

        function setupWork() {
            work = document.getElementById("work");
            setupCanvas(work);
        }


        ////////////////////
        // IMAGE DROPPING //
        ////////////////////

        $('.dropper')
            .on('dragover', (e) => {
                e.preventDefault();
            })
            .on('drop', (e) => {
                e.preventDefault();
                setStatus("Setting up image...", true);

                let files = e.originalEvent.dataTransfer.files;
                if (files.length > 0) {

                    // TODO error if more than 1 file?
                    let reader = new FileReader();
                    reader.onload = e => {
                        setImage(e.target.result);
                        clearStatus();
                    };
                    reader.readAsDataURL(files[0]);
                }
            });

        $('.load-sample')
            .on('click', (e) => {
                e.preventDefault();
                setStatus("Setting up sample image...", true);
                setImage("sample.jpg");
                clearStatus();
            });

        function setImage(src) {

            // store the image in a hidden img tag
            $("#dropped-image")
                .load(() => {
                    $(".dropper").hide();
                    drawDroppedImage();
                })
                .attr("src", src);
        }

        function drawDroppedImage() {
            let image = document.getElementById("dropped-image");

            let scaleX = work.width / image.width;
            let scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);

            $("#base-image")
                .attr("src", image.src)
                .attr("width", imageToLogicalCanvas(image.width))
                .attr("height", imageToLogicalCanvas(image.height));
        }

        ////////////////////
        // CANVAS DRAWING //
        ////////////////////

        function renderPrecisionHelper() {
            let pc = precisionHelper.ctx;
            let W = precisionHelper.W;
            let H = precisionHelper.H;
            let w = precisionHelper.w;
            let h = precisionHelper.h;

            pc.clearRect(0, 0, W, H);

            pc.lineWidth = logicalCanvastoPhysicalCanvas(1);
            pc.strokeStyle = readCssVar("current-selection-stroke");

            if (currentCircle) {
                let image = document.getElementById("dropped-image");
                let x = currentCircle.startX;
                let y = currentCircle.startY;
                let r = currentCircle.r;

                // TODO make this prettier, maybe it's possible to do all 9 cases in a general function like this?
                function drawImageSquare(xx, yy) {  // x, y from -1, 0, 1
                    let zoom = 1 / precisionHelperZoom;
                    let rad = (xx != 0 && yy != 0) ? (r / Math.sqrt(2)) : r;  // corners
                    pc.drawImage(
                        image,
                        x + (xx * rad) - w/6 * zoom,
                        y + (yy * rad) - h/6 * zoom,
                        w/3 * zoom,
                        h/3 * zoom,
                        (1 + xx) * W/3,
                        (1 + yy) * H/3,
                        W/3,
                        H/3
                        );
                }

                let selectionRadius = r * dpr * precisionHelperZoom;

                // center
                //pc.drawImage(image, x - w/6 * precisionHelperZoom, y - h/6 * precisionHelperZoom, w/3 * precisionHelperZoom, h/3 * precisionHelperZoom, W/3, H/3, W/3, H/3);
                drawImageSquare(0, 0);
                pc.beginPath();
                pc.moveTo(W/2-W/18, H/2-H/18);
                pc.lineTo(W/2-W/72, H/2-H/72);
                pc.moveTo(W/2+W/72, H/2+H/72);
                pc.lineTo(W/2+W/18, H/2+H/18);
                pc.moveTo(W/2+W/18, H/2-H/18);
                pc.lineTo(W/2+W/72, H/2-H/72);
                pc.moveTo(W/2-W/72, H/2+H/72);
                pc.lineTo(W/2-W/18, H/2+H/18);
                pc.rect(W/2, H/2, 0.5 * dpr, 0.5 * dpr);
                pc.stroke();

                // top
                //pc.drawImage(image, x - w/6, y - r - h/6, w/3, h/3, W/3, 0, W/3, H/3);
                drawImageSquare(0, -1);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, H/6 + selectionRadius, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom
                //pc.drawImage(image, x - w/6, y + r - h/6, w/3, h/3, W/3, 2*H/3, W/3, H/3);
                drawImageSquare(0, 1);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, 5*H/6 - selectionRadius, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // left
                //pc.drawImage(image, x - r - w/6, y - h/6, w/3, h/3, 0, H/3, W/3, H/3);
                drawImageSquare(-1, 0);
                pc.save();
                pc.beginPath();
                pc.rect(0, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius, H/2, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // right
                //pc.drawImage(image, x + r - w/6, y - h/6, w/3, h/3, 2*W/3, H/3, W/3, H/3);
                drawImageSquare(1, 0);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius, H/2, selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top left
                //pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 0, 0, W/3, H/3);
                drawImageSquare(-1, -1);
                pc.save();
                pc.beginPath();
                pc.rect(0, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius / Math.sqrt(2), H/6 + selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top right
                //pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 0, W/3, H/3);
                drawImageSquare(1, -1);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius / Math.sqrt(2), H/6 + selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom left
                //pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 0, 2*H/3, W/3, H/3);
                drawImageSquare(-1, 1);
                pc.save();
                pc.beginPath();
                pc.rect(0, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + selectionRadius / Math.sqrt(2), 5*H/6 - selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom right
                //pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 2*H/3, W/3, H/3);
                drawImageSquare(1, 1);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - selectionRadius / Math.sqrt(2), 5*H/6 - selectionRadius / Math.sqrt(2), selectionRadius, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();
            }

            pc.beginPath();
            pc.moveTo(W/3, 0);
            pc.lineTo(W/3, H);
            pc.moveTo(2*W/3, 0);
            pc.lineTo(2*W/3, H);
            pc.moveTo(0, H/3);
            pc.lineTo(W, H/3);
            pc.moveTo(0, 2*H/3);
            pc.lineTo(W, 2*H/3);
            pc.lineWidth = logicalCanvastoPhysicalCanvas(2);
            pc.strokeStyle = readCssVar("precision-helper-dividers-stroke");
            pc.stroke();
        }

        function renderWork() {
            let wc = work.getContext("2d");

            wc.clearRect(0, 0, work.width, work.height);  // TODO do this more neatly or is it neat/fast enough?

            if (currentCircle) {

                wc.strokeStyle = readCssVar("current-selection-stroke");

                wc.beginPath();
                wc.setLineDash([logicalCanvastoPhysicalCanvas(6), logicalCanvastoPhysicalCanvas(4)]);
                wc.arc(imageToPhysicalCanvas(currentCircle.startX), imageToPhysicalCanvas(currentCircle.startY), imageToPhysicalCanvas(currentCircle.r), 0, 2 * Math.PI);
                wc.moveTo(imageToPhysicalCanvas(currentCircle.startX), imageToPhysicalCanvas(currentCircle.startY));
                wc.lineTo(imageToPhysicalCanvas(currentCircle.x), imageToPhysicalCanvas(currentCircle.y));
                wc.lineWidth = logicalCanvastoPhysicalCanvas(1);
                wc.stroke();
                wc.setLineDash([]);

                // TODO if include surroundings
                if (includeSurroundings) {
                    let h = horizonalSurroundingsRange;
                    let v = verticalSurroundingsRange;

                    wc.beginPath();
                    wc.setLineDash([logicalCanvastoPhysicalCanvas(2), logicalCanvastoPhysicalCanvas(3)]);
                    wc.rect(
                        imageToPhysicalCanvas(currentCircle.startX - (h + 1) * currentCircle.r),
                        imageToPhysicalCanvas(currentCircle.startY - (v + 1) * currentCircle.r),
                        imageToPhysicalCanvas((2 * h + 2) * currentCircle.r),
                        imageToPhysicalCanvas((2 * v + 2) * currentCircle.r)
                        );
                    wc.stroke();
                    wc.setLineDash([]);
                }
            }

            if (showOldSelections) {
                wc.strokeStyle = readCssVar("old-selections-stroke");
                wc.fillStyle = readCssVar("old-selections-fill");
                circles.forEach(circle => {
                    wc.beginPath();
                    wc.arc(circle.x * scale, circle.y * scale, circle.r * scale, 0, 2 * Math.PI);
                    wc.fill();
                    wc.stroke();
                });
            }
        }

        $("#work")
            .mousedown((event) => {
                currentlySelectingCircle = true;
                currentCircle = {
                    startX: logicalCanvasToImage(event.pageX),  // - $("#work").offset().left if top left corner of canvas were not at (0,0)
                    startY: logicalCanvasToImage(event.pageY),  // analogous
                    x: logicalCanvasToImage(event.pageX),
                    y: logicalCanvasToImage(event.pageY),
                    r: 0
                };
            })
            .mousemove((event) => {
                if (currentlySelectingCircle) {
                    x = logicalCanvasToImage(event.pageX);  // see caveat above
                    y = logicalCanvasToImage(event.pageY);  // analogous

                    let dy = Math.abs(y - currentCircle.startY);
                    let dx = Math.abs(x - currentCircle.startX);
                    r = Math.sqrt(dx ** 2 + dy ** 2);

                    currentCircle.x = x;
                    currentCircle.y = y;
                    currentCircle.r = r;
                    renderWork();
                    renderPrecisionHelper();
                }
            })
            .mouseup((event) => {
                currentlySelectingCircle = false;
            });


        /////////////////////////
        // CROPPING & DOWNLOAD //
        /////////////////////////

        function cropAndDownload(circle) {
            let x = circle.x;
            let y = circle.y;
            let r = circle.r;

            let imageType = "image/png";
            let imageQuality = 1;
            let imageExtension = ".png";
            if (includeSurroundings) {
                imageType = "image/jpeg";
                imageExtension = ".jpg";
            }

            let width = Math.ceil(r * 2);
            let height = Math.ceil(r * 2);
            if (includeSurroundings) {
                width += 2 * r * horizonalSurroundingsRange;
                height += 2 * r * verticalSurroundingsRange;
            }

            let image = document.getElementById("dropped-image");
            let croppedImage = document.getElementById("cropped-image");

            croppedImage.setAttribute("width", width);
            croppedImage.setAttribute("height", height);

            let cic = croppedImage.getContext("2d");
            cic.clearRect(0, 0, width, height);

            if (includeSurroundings) {
                cic.drawImage(image, x - r - r * horizonalSurroundingsRange, y - r - r * verticalSurroundingsRange, width, height, 0, 0, width, height);
            }
            else {
                cic.save();
                cic.beginPath();
                cic.arc(r, r, r, 0, 2 * Math.PI);
                cic.closePath();
                cic.clip();
                cic.drawImage(image, x - r, y - r, width, height, 0, 0, width, height);
                cic.restore();
            }

            croppedImage.toBlob(blob => {
                let url = URL.createObjectURL(blob)

                let dummyLink = document.createElement("a");
                dummyLink.setAttribute("href", url);
                dummyLink.setAttribute("download", "cropcircles-x" + parseInt(x) + "y" + parseInt(y) + "r" + parseInt(r) + imageExtension);
                dummyLink.style.display = "none";
                document.body.appendChild(dummyLink);
                dummyLink.click();
                document.body.removeChild(dummyLink);

                URL.revokeObjectURL(url);
            }, imageType, imageQuality);
        }


        //////////////////////////
        // KEYBOARD INTERACTION //
        //////////////////////////

        function acceptCurrentCircle() {
            setStatus("Cropping image...", true);

            circles.push({
                x: currentCircle.startX,
                y: currentCircle.startY,
                r: currentCircle.r
            });
            currentCircle = null;
            cropAndDownload(circles[circles.length-1]);

            renderWork();
            renderPrecisionHelper();

            clearStatus();
        }

        function cancelCurrentCircle() {
            currentCircle = null;
            renderWork();
            renderPrecisionHelper();
        }

        function scaleCurrentCircle(s) {
            currentCircle.r += s;

            // this took some figuring out!
            let f = currentCircle.r / (currentCircle.r - s);
            currentCircle.x = currentCircle.startX + (currentCircle.x - currentCircle.startX) * f;
            currentCircle.y = currentCircle.startY + (currentCircle.y - currentCircle.startY) * f;

            renderWork();
            renderPrecisionHelper();
        }

        function moveCurrentCircle(x, y) {
            currentCircle.startX += x;
            currentCircle.startY += y;
            currentCircle.x += x;
            currentCircle.y += y;

            renderWork();
            renderPrecisionHelper();
        }

        // TODO only enable this once image has been dropped and a selection has been made?
        window.addEventListener("keydown", function (event) {
            let factor = 1;
            let larger = 20;
            if (event.shiftKey) {
                factor = larger;
            }

            switch (event.key) {
                case "Enter":
                    acceptCurrentCircle();
                    break;
                case "Escape":
                    cancelCurrentCircle();
                    break;

                case "ArrowUp":
                case "w":
                case "W":
                    moveCurrentCircle(0, -factor);
                    break;
                case "ArrowDown":
                case "s":
                case "S":
                    moveCurrentCircle(0, factor);
                    break;
                case "ArrowLeft":
                case "a":
                case "A":
                    moveCurrentCircle(-factor, 0);
                    break;
                case "ArrowRight":
                case "d":
                case "D":
                    moveCurrentCircle(factor, 0);
                    break;

                case "+":
                case "p":
                case "P":
                    scaleCurrentCircle(factor);
                    break;
                case "*":  // "shift +" on the German keyboard layout i use
                    scaleCurrentCircle(larger);
                    break;
                case "-":
                case "o":
                case "O":
                    scaleCurrentCircle(-factor);
                    break;
                case "_":  // "shift -" on the German keyboard layout i use
                    scaleCurrentCircle(-larger);
                    break;

                default:
                  return;  // quit when we don't want to handle the key event
              }

              // TODO switch based on .code ("KeyW", etc.) for wasd. how to handle default case above then?

            // cancel the default action to avoid it being handled twice
            event.preventDefault();
        }, true);


        ////////////
        // STATUS //
        ////////////

        // helper function for displaying status messages
        function setStatus(message, persist) {
            let status = document.querySelector("footer");
            status.innerHTML = message;
            status.className = "";
            if (!persist) {
                setTimeout(clearStatus, 500);
            }
        }

        // helper function for hiding the current status message
        function clearStatus() {
            let status = document.querySelector("footer");
            status.className = "hidden";
        }


        ////////////
        // CONFIG //
        ////////////

        let showOldSelections = true;
        let showOldSelectionsCheckbox = document.querySelector(".show-old-selections-checkbox");
        let precisionHelperZoom = 1;
        let precisionHelperZoomSlider = document.querySelector(".precision-helper-zoom-slider");

        // TODO
        let includeSurroundings = true;
        let horizonalSurroundingsRange = 1.6;
        let verticalSurroundingsRange = 0.3;

        // process config, restore settings from local storage if existant
        function setupConfig() {

            // restore settings from local storage
            if (showOldSelections = window.localStorage.getItem("show-old-selections")) {
                showOldSelectionsCheckbox.checked = showOldSelections == "yes";
                updateShowOldSelections(showOldSelectionsCheckbox);
            } else {
                updateShowOldSelections(showOldSelectionsCheckbox);
                // TODO not sure why that's required since the variable is set to true.
                // but if this line is not run: on first load with no local storage set yet, old circs don't show up until the checkbox is toggled twice
            }

            if (precisionHelperZoom = window.localStorage.getItem("precision-helper-zoom")) {
                precisionHelperZoomSlider.value = precisionHelperZoom;
                adjustPrecisionHelperZoom(precisionHelperZoomSlider.value);
            } else {
                adjustPrecisionHelperZoom(precisionHelperZoomSlider.value);
            }

            // TODO more settings
        }

        function updateShowOldSelections(checkbox) {
            showOldSelections = !!checkbox.checked;
            window.localStorage.setItem("show-old-selections", !!checkbox.checked ? "yes" : "no");
            renderWork();  // TODO but only if image has already been dropped
        }

        function adjustPrecisionHelperZoom(zoom) {
            precisionHelperZoom = zoom;
            precisionHelperZoomSlider.parentNode.querySelector("b").innerHTML = precisionHelperZoom + "×";
            window.localStorage.setItem("precision-helper-zoom", precisionHelperZoom);
            renderPrecisionHelper();
        }

        function resetSettings() {
            showOldSelectionsCheckbox.checked = showOldSelectionsCheckbox.getAttribute("data-default");
            updateShowOldSelections(showOldSelectionsCheckbox);
            precisionHelperZoomSlider.value = precisionHelperZoomSlider.getAttribute("data-default");
            adjustPrecisionHelperZoom(precisionHelperZoomSlider.value);
        }

        function nukeLocalStorage() {
            localStorage.removeItem("show-old-selections");
            localStorage.removeItem("precision-helper-zoom");
        }

        //////////////////
        // USER'S GUIDE //
        //////////////////

        function showUsersGuide() {
            $(".users-guide").show();
        }

        function hideUsersGuide() {
            $(".users-guide").hide();
        }


        ////////////////////////////////////
        // IT'S LIGHTS OUT AND AWAY WE GO //
        ////////////////////////////////////

        $(document).ready(() => {
            if (window.devicePixelRatio) {
                dpr = window.devicePixelRatio;
            }

            setupPrecisionHelper();
            setupWork();

            setupConfig();
        });
    </script>
</body>
</html>
