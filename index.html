<html class="light">
<head>
    <meta charset="utf-8" lang="en">
    <title>Crop Circles</title>
    <link rel="stylesheet" href="libs/ttf-iosevka-aile-3.4.6/iosevka-aile.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            --font-size: 14px;
            --font-stack: "Iosevka Aile Web", monospace;

            --sidebar-width: 18rem;
            --sidebar-background-color: #222;

            --status-background-color: #444;

            --precision-helper-background-color: #000;

            --text-color: #eee;
            --link-color: #bbb;
            --hover-color: #999;
            --kbd-background-color: #444;

            --rule-color: #666;

            --input-background-color: #333;
            --input-border-color: #555;
            --input-hover-background-color: #555;
            --input-hover-border-color: #888;
            --input-focused-background-color: #888;
            --input-placeholder-color: #777;
            --input-current-value-color: #aaa;

            --dropper-background-color: #555;
            --dropper-color: #aaa;


            font-size: var(--font-size);
            font-family: var(--font-stack);
            letter-spacing: -0.02em;
        }
        body {
            color: var(--text-color);
        }

        /* SIDEBAR */
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--sidebar-background-color);
            padding: 1em;
            position: fixed;
            right: 0;
            height: calc(100% - var(--sidebar-width));
            overflow-y: scroll;
        }
        h1 {
            font-size: 4em;
            font-weight: 200;
            line-height: 0.85em;
            letter-spacing: -0.1em;
            text-transform: uppercase;
            margin: -0.07em 0 0 -0.07em;
            text-align: right;
        }
        p {
            margin: 1em 0;
        }
        a {
            color: var(--link-color);
            text-decoration: underline;
        }
        a:hover {
            color: var(--hover-color);
        }
        hr {
            border: none;
            border-top: 1px solid var(--rule-color);
            margin: 1rem 0;
        }
        kbd {
            font: inherit;
            background-color: var(--kbd-background-color);
            padding: 0 0.2rem;
            border-radius: 0.2rem
        }
        button, label, input[type="text"] {
            font: inherit;
            color: inherit;
            background-color: var(--input-background-color);
            border: 1px solid var(--input-border-color);
            text-align: left;
            margin: 1em 0 0.3em 0;
            padding: 0.5em 0.7em;
            display: block;
            width: 100%;
            text-transform: uppercase;
            border-radius: 0.2rem
        }
        button:hover, label:hover, input[type="text"]:hover {
            background-color: var(--input-hover-background-color);
            border-color: var(--input-hover-border-color);
        }
        button b {
            float: right;
            height: 0;
            margin-top: -0.3em;
        }
        input[type="range"] {
            width: 100%;
            margin: 0;
            margin-bottom: 0.3em;
        }
        input[type="text"]::placeholder {
            color: var(--input-placeholder-color);
        }
        input[type="text"]:focus,
        button:active {
            border-color: var(--input-focused-background-color);
            background-color: var(--input-focused-background-color);
            outline: none;
        }
        label b {
            font-weight: normal;
            float: right;
            color: var(--input-current-value-color);
        }
        span {
            font-size: 0.85em;
            display: block;
        }
        a.reset {
            display: inline-block;
            text-transform: uppercase;
            text-decoration: none !important;
            font-size: 0.6em !important;
            letter-spacing: 1px;
        }

        /* STATUS */
        footer {
            position: fixed;
            right: 0;
            bottom: var(--sidebar-width);
            width: var(--sidebar-width);
            background-color: var(--status-background-color);
            padding: 1em;
            font-size: 0.8em;
            pointer-events: none;
            opacity: 1;
        }
        footer.hidden {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }

        /* PRECISION HELPER */
        .precision-helper {
            position: fixed;
            width: var(--sidebar-width);
            height: var(--sidebar-width);
            bottom: 0;
            right: 0;
            background-color: var(--precision-helper-background-color);
        }
        .precision-helper canvas {
            width: 100%;
            height: 100%;
        }

        /* CROPPING VIEW */
        main {
            width: calc(100vw - var(--sidebar-width));
            height: 100vh;
            background: repeating-linear-gradient(
                -42deg,
                #080808,
                #080808 13px,
                #181818 13px,
                #181818 20px); /* TODO revisit, or move to variables */
        }
        .dropper {
            padding: 1px; /* fix for margin weirdness */
            background-color: var(--dropper-background-color);
            height: 100%;
        }
        .dropper-text {
            border: 0.35rem dashed var(--dropper-color);
            border-radius: 1em;
            color: var(--dropper-color);
            font-size: 3em;
            width: 40%;
            margin: auto;
            margin-top: 20vh;
            padding: 4rem 2rem;
            text-align: center;
            font-weight: 500;
            letter-spacing: -0.05em;
        }
        .load-sample {
            display: block;
            font-size: 2rem;
            margin-top: 1em;
            cursor: pointer;
        }
        #dropped-image {
            display: none;
        }
        #work {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* GITHUB CORNER */
        @keyframes octocat-wave {
            0%, 100% {
                transform:rotate(0);
            }
            20%, 60% {
                transform:rotate(-25deg);
            }
            40%, 80% {
                transform:rotate(10deg);
            }
        }
        .github-corner:hover .octo-arm {
            animation:octocat-wave 560ms ease-in-out;
        }
        .github-corner svg {
            --github-corner-size: 4rem;

            fill: var(--link-color);
            color: var(--sidebar-background-color);
            position: fixed;
            top: 0;
            transform: rotate(-90deg);
            right: calc(var(--sidebar-width) - var(--github-corner-size));
            width: var(--github-corner-size);
            height: var(--github-corner-size);
        }
        .github-corner svg:hover {
            fill: var(--hover-color) !important;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <h1><em>Crop</em> Circles</h1>
        <p>A tool for cropping <a href="https://en.wikipedia.org/wiki/Center_pivot_irrigation">center pivot irrigation</a> fields from aerial imagery. <a href="https://github.com/doersino/cropcircles#readme">Learn more…</a></p>

        <span><strong>Usage:</strong> Drop an image into the main area. Click and drag from a center point to make a circular selection. Keeping an eye on the precision helper in the bottom right, adjust the selection via the arrow keys <kbd>↑</kbd> <kbd>↓</kbd> <kbd>←</kbd> <kbd>→</kbd>; you can zoom in or out via <kbd>+</kbd> and <kbd>-</kbd>. You can press <kbd>shift</kbd> to adjust in 10× larger increments. When satisfied, press <kbd>enter</kbd> to accept the selected circle – it will then download as a PNG image with a transparent background.</span>

        <hr>

        <label><input type="checkbox" class="show-old-selections-checkbox" data-default="yes" onclick="toggleShowOldSelections(this);" checked> show old selections</label>
        <span>Show previously selected circles to help you keep track of what you've already done.</span>

        TODO dropdown for background color: transparent, black, white, image content

        <!--<button onclick="copySource(this);">copy source<b></b></button>
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <input type="text" placeholder="Location">
        <span>The copied source will be surrounded with asterisks, ready for pasting into a Markdeep document.</span>

        <button onclick="downloadSVG();">download svg<b></b></button>
        <span>Handy for inserting your diagram into a non-Markdeep document. <em>Includes the source in a &lt;metadata&gt; tag.</em></span>

        <hr>

        <label><input type="checkbox" onclick="toggleDarkMode(this);" data-default="light" class="dark-mode-checkbox"> dark mode</label>

        <label>
            <input type="range" min="0.5" max="3.0" step="0.01" value="1.0" data-default="1.0" class="zoom-level-slider" oninput="adjustZoomLevel(this.value)">
            <br>zoom level <b>100%</b>
        </label>
        <span>Scales both source and preview.</span>

        <label>
            <input type="range" min="1.00" max="1.50" step="0.01" value="1.25" data-default="1.25" class="line-height-slider" oninput="adjustLineHeight(this.value)">
            <br>line height <b>1.25em</b>
        </label>
        <label>
            <input type="range" min="-0.30" max="0.45" step="0.01" value="0.15" data-default="0.15" class="letter-spacing-slider" oninput="adjustLetterSpacing(this.value)">
            <br>letter spacing <b>0.15px</b>
        </label>
        <span>Both of the above might need adjusting depending on your zoom level, browser and installed fonts.</span>-->

        <hr>

        <p><span><em>These settings are continually written to local storage and will be restored when you close and reopen this page.</em></span></p>
        <a class="reset" href="javascript:resetSettings();">reset settings</a>
    </aside>
    <aside class="precision-helper">
        <canvas id="prec"></canvas>
    </aside>
    <footer class="hidden"></footer>
    <main>
        <div class="dropper">
            <div class="dropper-text">
                Drop image here
                <em class="load-sample">…or <a>load sample</a>.</em>
            </div>
        </div>
        <img id="dropped-image">
        <canvas id="work"></canvas>
    </main>

    <img style="display: none;" id="dropped-image">

    <script src="https://code.jquery.com/jquery-latest.js" crossorigin="anonymous"></script>
    <script>

        //$('#work').hide();

        $('.dropper')
            .on('dragover', (e) => {
                e.preventDefault();
            })
            .on('drop', (e) => {
                e.preventDefault();
                setStatus("Setting up image...", true)
                let files = e.originalEvent.dataTransfer.files;
                if (files.length > 0) {
                    // TODO error if more than 1 file?
                    let reader = new FileReader();
                    reader.onload = (e) => {
                        // I save the image in an img component in case i want to restore to the initial image (img is hidden)
                        $("#dropped-image")
                            .load(() => {
                                // hide the original image and text in drag area
                                $(".dropper").hide();
                                //$('#work').show();
                                // display the canvas
                                // TODO display status
                                // draw canvas
                                drawDroppedImage();
                                clearStatus();

                            })
                            .attr("src", e.target.result);
                    };
                    reader.readAsDataURL(files[0]);
                }
            });

        $('.load-sample')
            .on('click', (e) => {
                e.preventDefault();
                setStatus("Setting up image...", true)
                $("#dropped-image")
                    .load(() => {
                        // hide the original image and text in drag area
                        $(".dropper").hide();
                        //$('#work').show();
                        // display the canvas
                        // TODO display status
                        // draw canvas
                        drawDroppedImage();
                        clearStatus();
                    })
                    .attr("src", "sample.jpg");
            });

        function initCanvas(elem) {

            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels
            var w = elem.offsetWidth;
            var h = elem.offsetHeight;
            var dpr = 1;
            var W, H;
            if (window.devicePixelRatio) {
                dpr = window.devicePixelRatio;
                elem.style.width = w + "px";
                elem.style.height = h + "px";
                W = w * dpr;
                H = h * dpr;
            }
            elem.setAttribute("width", W);
            elem.setAttribute("height", H);

            return {
                elem: elem,
                ctx: elem.getContext("2d"),
                w: w,
                h: h,
                W: W,
                H: H,
                dpr: dpr
            }
        }

        let prec = document.getElementById("prec");
        let pcanv = initCanvas(prec);
        let pc = pcanv.ctx;
        let W = pcanv.W;
        let H = pcanv.H;
        let w = pcanv.w;
        let h = pcanv.h;

        let dpr = pcanv.dpr;


        let work = document.getElementById("work");
        let wcanv = initCanvas(work);
        let wc = work.getContext("2d");
        let scale = 1;
        // TODO do the init after the the image has been dropped?

        function drawDroppedImage() {
            var image = document.getElementById("dropped-image");
            var scaleX = work.width / image.width;
            var scaleY = work.height / image.height;
            scale = Math.min(scaleX, scaleY);
            wc.drawImage(image, 0, 0, image.width, image.height, 0, 0, scale * image.width, scale * image.height);
            // TODO get the aspect ratio right
        }

        function redrawCurrentImage(image) {
            work.width = image.width;
            work.height = image.height;
            // TODO also update w, h etc.?
            wc.drawImage(image, 0, 0, image.width, image.height);
            // TODO get the aspect ratio right
        }

        function updatePrec(x, y, r) {
            pc.clearRect(0, 0, W, H);

            pc.lineWidth = 1;
            pc.strokeStyle = "#fff";

            if (x) {
                var image = document.getElementById("dropped-image");

                // center
                pc.drawImage(image, x - w/6, y - h/6, w/3, h/3, W/3, H/3, W/3, H/3);
                pc.beginPath();
                pc.moveTo(W/2-W/18, H/2-H/18);
                pc.lineTo(W/2-W/72, H/2-H/72);
                pc.moveTo(W/2+W/72, H/2+H/72);
                pc.lineTo(W/2+W/18, H/2+H/18);
                pc.moveTo(W/2+W/18, H/2-H/18);
                pc.lineTo(W/2+W/72, H/2-H/72);
                pc.moveTo(W/2-W/72, H/2+H/72);
                pc.lineTo(W/2-W/18, H/2+H/18);
                pc.rect(W/2, H/2, 1, 1);
                pc.stroke();

                // top
                pc.drawImage(image, x - w/6, y - r - h/6, w/3, h/3, W/3, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, H/6 + r * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom
                pc.drawImage(image, x - w/6, y + r - h/6, w/3, h/3, W/3, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/2, 5*H/6 - r * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // left
                pc.drawImage(image, x - r - w/6, y - h/6, w/3, h/3, 0, H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r * dpr, H/2, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // right
                pc.drawImage(image, x + r - w/6, y - h/6, w/3, h/3, 2*W/3, H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r * dpr, H/2, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top left
                pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 0, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r/Math.sqrt(2) * dpr, H/6 + r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // top right
                pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y - r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 0, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 0, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r/Math.sqrt(2) * dpr, H/6 + r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom left
                pc.drawImage(image, x - r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 0, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(0, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(W/6 + r/Math.sqrt(2) * dpr, 5*H/6 - r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // bottom right
                pc.drawImage(image, x + r/Math.sqrt(2) - w/6, y + r/Math.sqrt(2) - h/6, w/3, h/3, 2*W/3, 2*H/3, W/3, H/3);
                pc.save();
                pc.beginPath();
                pc.rect(2*W/3, 2*H/3, W/3, H/3);
                pc.closePath();
                pc.clip();
                pc.beginPath();
                pc.arc(5*W/6 - r/Math.sqrt(2) * dpr, 5*H/6 - r/Math.sqrt(2) * dpr, r * dpr, 0, 2 * Math.PI);
                pc.stroke();
                pc.restore();

                // TODO now, implement:
                // * move stuff to render function based on image, old circles, current circle
                // * keeping around of old circles in an organized manner, and visually distinct from current cirle (fill? gray?)
                // * adjustments of circles via keyboard and acceptance
                // * the actual cropping and downloading of images upon acceptance
                // * maybe a list in the sidebar, with a re-download possibility
                // * stroke colors from css variables, or js variables
                // * code cleanup
                // * think of additional, more useful settings
                // * maybe support for browser resizing, but that's a buncha work for zero benefit in practice
            }

            pc.beginPath();
            pc.moveTo(W/3, 0);
            pc.lineTo(W/3, H);
            pc.moveTo(2*W/3, 0);
            pc.lineTo(2*W/3, H);
            pc.moveTo(0, H/3);
            pc.lineTo(W, H/3);
            pc.moveTo(0, 2*H/3);
            pc.lineTo(W, 2*H/3);
            pc.lineWidth = 2;
            pc.strokeStyle = "#555";
            pc.stroke();
        }
        updatePrec(null, null, null);
        // TODO divide into 9 views: center and edges. draw at full res (i.e. draw pixels as 2x2 on @2x)


        var started = false;
        var position = null;  // not valid yet
        var image;
        var startX = 0;
        var startY = 0;
        var x = 0;
        var y = 0;
        var r = 0;

        var circs = [];

        $("#work")
            .mousedown((event) => {
                position = $("#work").offset();
                startX = event.pageX - position.left;
                startY = event.pageY - position.top;
                started = true;
                image = new Image;
                image.src = work.toDataURL("image/png");  // TODO this isn't fast – might another format be better?
                // TODO or, alternatively, draw input image on a separate layer/canvas behind programmatic stuff? since it doesn't ever actually change
            })
            .mousemove((event) => {
                if (started) {
                    redrawCurrentImage(image);

                    x = event.pageX - position.left;
                    y = event.pageY - position.top;

                    var dy = Math.abs(y - startY);
                    var dx = Math.abs(x - startX);
                    r = Math.sqrt(dx ** 2 + dy ** 2);

                    wc.setLineDash([6*dpr, 4*dpr]);
                    wc.arc(startX * dpr, startY * dpr, r * 2, 0, 2 * Math.PI);
                    wc.moveTo(startX * dpr, startY * dpr);
                    wc.lineTo(x * dpr, y * dpr);
                    wc.lineWidth = 2;
                    wc.strokeStyle = "#fff";
                    wc.stroke();
                    wc.setLineDash([]);

                    // TODO store definition of cirle: xstart, ystart, r
                    updatePrec(startX * dpr / scale, startY * dpr / scale, r * dpr / scale);

                }
            })
            .mouseup((event) => {
                if (started) {
                    started = false;
                    circs.push({x: startX * dpr / scale, y: startX * dpr / scale, r: r * dpr / scale});
                }
            });


        // helper function for displaying status messages
        function setStatus(message, persist) {
            var status = document.querySelector("footer");
            status.innerHTML = message;
            status.className = "";
            if (!persist) {
                setTimeout(clearStatus, 500);
            }
        }

        function clearStatus() {
            var status = document.querySelector("footer");
            status.className = "hidden";
        }

        var showOldSelections = true;
        var showOldSelectionsCheckbox = document.querySelector(".show-old-selections-checkbox");

        // set up canvases and restore settings from local storage
        function setup() {

            // restore settings from local storage
            if (showOldSelections = window.localStorage.getItem("show-old-selections")) {
                showOldSelectionsCheckbox.checked = showOldSelections == "yes";
                toggleShowOldSelections(showOldSelectionsCheckbox);
            }

            // TODO more
        }
        setup();

        function toggleShowOldSelections(checkbox) {
            showOldSelections = !!checkbox.checked;
            window.localStorage.setItem("show-old-selections", !!checkbox.checked ? "yes" : "no");
        }

        function resetSettings() {
            showOldSelectionsCheckbox.checked = showOldSelectionsCheckbox.getAttribute("data-default");
            toggleShowOldSelections(showOldSelectionsCheckbox);
        }

        function nukeLocalStorage() {
            localStorage.removeItem("show-old-selections");
        }
    </script>

    <a href="https://github.com/doersino/cropcircles" class="github-corner" aria-label="View source on GitHub">
        <svg viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
</body>
</html>
